#!/bin/bash

# flush terminal log to the file
function detail.aish_flush_script_log
{
  kill -USR1 $AISH_PID
}
# truncate the terminal log
function detail.aish_truncate_script_log
{
  truncate -s 0 $AISH_LOGFILE
}
# write the terminal log to the part file
function aish_rollout
{
  detail.aish_flush_script_log
  if [[ ! -f "$AISH_SESSION"/mute ]]; then
    cat $AISH_LOGFILE | $AISH_RENDER_BIN > $AISH_PART/part_$(date +%Y%m%d_%H%M%S)_user.txt
  fi
  detail.aish_truncate_script_log
}
# clear the part files
function aish_clear
{
  rm -f $AISH_PART/part_*
  rm -f $AISH_SESSION/codeblock_*
  rm -f $AISH_SESSION/approved_lines
  detail.aish_flush_script_log
  detail.aish_truncate_script_log
  clear
}
function aish_mute
{
  aish_rollout
  touch $AISH_SESSION/mute
}
function aish_unmute
{
  detail.aish_flush_script_log
  detail.aish_truncate_script_log
  rm -f $AISH_SESSION/mute
}
# list the part files
function aish_ls
{
  cd $AISH_PART
  ls part_* | sort -r | nl
  cd - > /dev/null
}
# list sessions
function aish_sessions
{
  local sessions_dir="${AISH_HOME}/sessions"
  ls -1 "$sessions_dir" 2>/dev/null | grep -v "latest" | sort -r
}
function aish_last
{
  # show the last part file
  # usage: aish_last [-f] [-n <number>]
  # -f: full path
  # -n: skip <number> of files from the end
  # example: aish_last -f -n 2

  local full_path=false
  local skip=1

  while getopts "fn:" opt; do
    case $opt in
      f)
        full_path=true
        ;;
      n)
        if ! [[ "$OPTARG" =~ ^[0-9]+$ ]] || [[ "$OPTARG" -lt 1 ]]; then
          echo "Invalid argument for -n: $OPTARG" >&2
          return 1
        fi
        skip="$OPTARG"
        ;;
      *) echo "Invalid option: -$OPTARG" >&2; return 1 ;;
    esac
  done
  shift $((OPTIND - 1))
 
  if [[ "$full_path" == true ]]; then
    files="$(ls -1 "$AISH_PART"/part_*)"
  else
    files="$(ls -1 "$AISH_PART" | grep 'part_*')"
  fi

  if [[ -z "$files" ]]; then
    return 0
  fi
  echo "$files" | tail -n "$skip" | head -n 1
}
# remove the last part file
function aish_rm_last
{
  cd $AISH_SESSION
  files="$(ls | grep 'part_*')"
  if [[ -z "$files" ]]; then
    return
  fi
  last="$(echo "$files" | tail -n 1)"
  rm -v $last
  cd - > /dev/null
}
function detail.aish_find_dot_aish
{
  current_dir=$(pwd)
  while [ "$current_dir" != "/" ]; do
    if [ -d "$current_dir/.aish" ]; then
      echo "$current_dir/.aish"
      return 0
    fi
    current_dir=$(dirname "$current_dir")
  done
  return 1
}
# calculate the message size
function detail.aish_calc_message_size
{
  detail.aish_flush_script_log
  cat $AISH_LOGFILE | $AISH_RENDER_BIN > $AISH_SESSION/tmp_user.txt
  if [[ -f "$AISH_SESSION"/mute ]]; then
    echo -n "---"
    return
  fi
  env LANG=C du --apparent-size -ch $(detail.aish_list_parts) $AISH_SESSION/tmp_user.txt | grep 'total$' | sed -e 's/[ \t]\+total$//'
}
# list the part files for the message that is sent
function detail.aish_list_parts
{
  if [[ -z "$1" ]]; then
    max_send=$AISH_MAX_SEND_MESSAGE
  else
    max_send=$1
  fi
  if [[ -z "$max_send" ]]; then
    echo $AISH_PART/part_*
    return
  fi
  files=$(find $AISH_PART -name 'part_*')
  if [[ -z "$files" ]]; then
    return
  fi
  ls $files | tail -n $max_send
}
# write the code block to individual files
function detail.aish_pickup_codeblock
{
  start_marker='```'
  end_marker='```'

  while IFS= read -r line; do
    if [[ "$line" =~ ^\ *"$start_marker"* ]]; then
      file_name="$AISH_SESSION/codeblock_$(date +%Y%m%d_%H%M%S)_$(printf '%02d' $file_num).txt"
      file_num=$((file_num + 1))
      while IFS= read -r code_line; do
        if [[ "$code_line" =~ ^\ *"$end_marker" ]]; then
          break
        fi
        echo "$code_line" >> "$file_name"
      done
    else
      if [[ "$line" =~ \`.+\` ]]; then
        echo "$line" >> "$AISH_SESSION/codeblock_$(date +%Y%m%d_%H%M%S)_$(printf '%02d' $file_num).txt"
      fi
    fi
  done
}

function detail.aish_log_request
{
  echo '{"type":"request","timestamp":"'$(date +%Y-%m-%dT%H:%M:%S.%NZ)'", "payload":' >> $LOG
  echo "$1"'}' >> $LOG
}
function detail.aish_log_response
{
  echo '{"type":"response","timestamp":"'$(date +%Y-%m-%dT%H:%M:%S.%NZ)'", "payload":' >> $LOG
  echo "$1"'}' >> $LOG
}

function detail.aish_log_tool
{
  echo -e "\033[0;32m[Tool] $*\033[0m" >&2
}

function detail.aish_filter_command
{
  local quiet_mode=""
  if [[ "$1" == "-q" ]]; then
    quiet_mode="-q"
  fi
  if [ ! -e "$AISH_SESSION"/approved_lines ]; then
    touch "$AISH_SESSION"/approved_lines
  fi
  "$AISH_HOME"/bin/leakscan "$AISH_HOME"/rules.json | grep -v $quiet_mode -F -f "$AISH_SESSION"/approved_lines
}

function detail.aish_filter_sensitive_info
{
  local matched=false
  local tmp_filtered=$(mktemp "$AISH_SESSION"/tmp_filtered.XXXXXX)
  if [[ ! -f "$tmp_filtered" ]]; then
    echo "Failed to create temporary file for filtering." >&2
    return 1
  fi

  trap 'rm -f "$tmp_filtered"' EXIT

  cat | detail.aish_filter_command > "$tmp_filtered"


  if [[ -s "$tmp_filtered" ]]; then
    matched=true
    echo "⚠️  SECURITY WARNING: Bad patterns matched" >&2
    echo "" >&2
    echo "----------------------------------------" >&2
    cat "$tmp_filtered" >&2
    echo "----------------------------------------" >&2
    echo >&2
  fi

  if [ "$matched" = true ]; then
    echo -n "Send request? ([y]es / [n]o / [a]lways allow this line): " >&2
    read -r confirm < /dev/tty
    if [[ "$confirm" == "a" ]]; then
      cat "$tmp_filtered" >> $AISH_SESSION/approved_lines
      echo "⚠️  SECURITY WARNING: Bad patterns matched, but the line is approved for future use." >&2
    elif [[ "$confirm" != "y" ]]; then
      echo "❌  Request has been aborted." >&2
      return 1
    fi
  fi

  return 0
}

function detail.aish_security_check
{
    # Security check for the files in the session
    # This function reads all files in the session directory and checks for sensitive information.
    # If any sensitive information is found, it prompts the user for confirmation to proceed.
    # If the user not confirm, the script exits with a non-zero status.

    if [[ "$skip_security_check" == "true" ]]; then
      echo "⚠️  SKIP SECURITY FILTER!!" >&2
    fi

    while IFS= read -r file; do
        if [[ "$skip_security_check" != "true" ]]; then
            if ! detail.aish_filter_sensitive_info < "$file"; then
              exit 1
            fi
        fi
        echo "$file"
    done
    return 0
}

function detail.aish_puts_as_markdown
{
  local header_level=1
  if [[ "$1" == "-h" ]]; then
    header_level="$2"
    shift 2
  fi

  local filenames="$@"

  for f in $filenames; do
    if [[ -f "$f" ]]; then
      echo
      echo
      printf '#%.0s' $(seq 1 $header_level)
      echo " $f"
      #echo -n "$(printf '%*s' $header_level | tr ' ' '#') $f"
      echo '```'
      cat "$f"
      echo
      echo '```'
      echo
      echo
    fi
  done
}

function json_escape
{
  jq -Rs '.' | sed 's/^"//;s/"$//'
}
function json_string
{
  jq -Rs '.'
}
# エラー出力関数
function puts_error
{
  echo "Error: $1" >&2
}

# モデル管理コマンド
function aish_models
{
    # model_manager.shを読み込む
    . "$AISH_HOME/lib/model_manager.sh"
    
    local provider=""
    local show_unsupported=false
    local show_available=false
    
    # オプション解析
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --provider|-p)
                if [ -z "$2" ]; then
                    puts_error "Option --provider requires a value"
                    echo "Usage: aish models [OPTIONS]"
                    return 1
                fi
                provider="$2"
                shift 2
                ;;
            --unsupported|-u)
                show_unsupported=true
                shift
                ;;
            --available)
                show_available=true
                shift
                ;;
            -h|--help)
                echo "Usage: aish models [OPTIONS]"
                echo ""
                echo "Options:"
                echo "  --provider <name>    Show models for specific provider (gemini, gpt, etc.)"
                echo "                       If not specified, show all providers"
                echo "  --unsupported        Show unsupported models (available from API but not in SUPPORTED_MODELS)"
                echo "                       Requires --provider option"
                echo "  --available          Show available models from API"
                echo "                       Requires --provider option"
                echo "  -h, --help          Show this help message"
                echo ""
                echo "Examples:"
                echo "  aish models                           # Show supported models for all providers"
                echo "  aish models --provider gpt            # Show supported models for GPT provider"
                echo "  aish models --provider gpt --unsupported  # Show unsupported models for GPT provider"
                echo "  aish models --provider gpt --available    # Show available models from API for GPT provider"
                return 0
                ;;
            *)
                puts_error "Unknown option: $1"
                echo "Usage: aish models [OPTIONS]"
                echo "Use 'aish models --help' for more information"
                return 1
                ;;
        esac
    done
    
    # 未対応モデル表示または利用可能モデル表示の場合はプロバイダ指定が必要
    if [ "$show_unsupported" = true ] || [ "$show_available" = true ]; then
        if [ -z "$provider" ]; then
            puts_error "--unsupported and --available options require --provider option"
            return 1
        fi
    fi
    
    # アクションに応じて処理
    if [ "$show_unsupported" = true ]; then
        list_unsupported_models "$provider"
    elif [ "$show_available" = true ]; then
        list_available_models "$provider"
    elif [ -z "$provider" ]; then
        # プロバイダが指定されていない場合、全プロバイダの対応モデルを表示
        list_all_supported_models
    else
        # 指定されたプロバイダの対応モデルを表示
        list_supported_models "$provider"
    fi
}

# 記憶管理コマンド
function aish_memory
{
    # memory_manager.shを読み込む
    . "$AISH_HOME/lib/memory_manager.sh"
    
    local action=""
    local ids=()
    
    # オプション解析
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --list|-l)
                action="list"
                shift
                ;;
            --show|-s)
                action="show"
                shift
                ;;
            --revoke|-r)
                action="revoke"
                shift
                ;;
            -h|--help)
                echo "Usage: aish memory [OPTIONS] [ID...]"
                echo ""
                echo "Options:"
                echo "  --list, -l              List all memories"
                echo "  --show [id...], -s [id...] Show detailed information for specific memories (default action)"
                echo "  --revoke [id...], -r [id...] Delete specific memories"
                echo "  -h, --help             Show this help message"
                echo ""
                echo "Examples:"
                echo "  aish memory --list                      # List all memories"
                echo "  aish memory --show 5b91615c 0fa71065   # Show details for multiple memories"
                echo "  aish memory 5b91615c 0fa71065          # Same as above (default action)"
                echo "  aish memory --revoke 5b91615c 0fa71065 # Delete multiple memories"
                return 0
                ;;
            -*)
                puts_error "Unknown option: $1"
                echo "Usage: aish memory [OPTIONS] [ID...]"
                echo "Use 'aish memory --help' for more information"
                return 1
                ;;
            *)
                # If no action is set, default to show
                if [ -z "$action" ]; then
                    action="show"
                fi
                ids+=("$1")
                shift
                ;;
        esac
    done
    
    # アクションが指定されていない場合はエラー
    if [ -z "$action" ]; then
        puts_error "No action specified"
        echo "Usage: aish memory [OPTIONS] [ID...]"
        echo "Use 'aish memory --help' for more information"
        return 1
    fi
    
    # アクションに応じて処理
    case "$action" in
        list)
            local memories_json
            memories_json=$(list_memories)
            if [ $? -ne 0 ]; then
                puts_error "Failed to list memories"
                return 1
            fi
            
            # メモリの数を取得
            local count
            count=$(echo "$memories_json" | jq 'length' 2>/dev/null || echo "0")
            
            if [ "$count" = "0" ] || [ "$count" = "null" ]; then
                return 0
            fi
            
            # id\ttimestamp\tsubject 形式で表示
            echo "$memories_json" | jq -r '.[] | "\(.id)\t\(.timestamp | sub("T"; " ") | .[0:16])\t\(.subject // "")"'
            ;;
        show)
            if [ ${#ids[@]} -eq 0 ]; then
                puts_error "Option --show requires at least one memory ID"
                return 1
            fi
            
            for memory_id in "${ids[@]}"; do
                local memory_json
                memory_json=$(get_memory_content "$memory_id" 2>/dev/null)
                
                if [ $? -ne 0 ] || [ -z "$memory_json" ]; then
                    puts_error "Memory with id '$memory_id' not found"
                    continue
                fi
                
                # エラーチェック
                local error
                error=$(echo "$memory_json" | jq -r '.error // empty' 2>/dev/null)
                if [ ! -z "$error" ]; then
                    puts_error "Memory '$memory_id': $error"
                    continue
                fi
                
                echo "Memory Details (ID: $memory_id):"
                echo ""
                echo "$memory_json" | jq -r '
                    "ID: \(.id)\n" +
                    "Category: \(.category)\n" +
                    "Keywords: \(.keywords | join(", "))\n" +
                    "Timestamp: \(.timestamp)\n" +
                    "Usage Count: \(.usage_count)\n" +
                    "Source: \(.source // "unknown")\n" +
                    "Memory Directory: \(.memory_dir)\n" +
                    "Project Root: \(.project_root // "N/A")\n" +
                    "Content:\n\(.content)\n"
                '
                echo "----------------------------------------"
            done
            ;;
        revoke)
            if [ ${#ids[@]} -eq 0 ]; then
                puts_error "Option --revoke requires at least one memory ID"
                return 1
            fi
            
            for memory_id in "${ids[@]}"; do
                revoke_memory "$memory_id"
            done
            ;;
        *)
            puts_error "Unknown action: $action"
            return 1
            ;;
    esac
}