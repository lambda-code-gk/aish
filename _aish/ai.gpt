#!/usr/bin/env bash

set -eo pipefail

# OpenAI APIキーを設定
if [ -z "$OPENAI_API_KEY" ];
then
  puts_error "The OPENAI_API_KEY is missing or empty. Please set the API key generated from the OpenAI website."
  exit 1;
fi
API_KEY="$OPENAI_API_KEY"
ENDPOINT="https://api.openai.com/v1/chat/completions"

# 対応しているモデルの一覧
SUPPORTED_MODELS=(
#  "gpt-3.5-turbo"
#  "gpt-4o"
  "gpt-5.2"
)

MODEL="${MODEL:-gpt-5.2}"
TEMPERATURE="${TEMPERATURE:-0.7}"
LOG="$AISH_SESSION"/log.json

# 共通ライブラリを読み込む
. "$AISH_HOME/lib/agent_approve.sh"
. "$AISH_HOME/lib/tool_helper.sh"
. "$AISH_HOME/lib/tool_execute_shell_command.sh"
. "$AISH_HOME/lib/tool_save_memory.sh"
. "$AISH_HOME/lib/tool_search_memory.sh"
. "$AISH_HOME/lib/memory_manager.sh"
. "$AISH_HOME/lib/query_entry.sh"
. "$AISH_HOME/lib/llm_driver.sh"

# 全てのtoolファイルを読み込む
_load_all_tool_files

# OpenAI形式のリクエストJSONを生成（通常モード）
function _provider_make_request_payload
{
    query=$1
    system=$2

    echo '{"model": "'$MODEL'", "temperature": '$TEMPERATURE',"messages": ['

    if [ ! -z "$system" ]; then
      echo '  {"role": "system", "content": '"$(echo "$system" | json_string)"'}'
    fi

    local line_count=0
    while IFS= read -r file; do
        if [[ $line_count -gt 0 ]]; then
            echo -n ','
        fi
        line_count=$((line_count + 1))
        if [[ "$file" =~ "_user.txt" ]]; then
            echo '  {"role": "user", "content": '$(cat "$file" | json_string)'}'
        else
            echo '  {"role": "assistant", "content": '$(cat "$file" | json_string)'}'
        fi
    done

    user_input=$(echo -e "----\n# user message:\n$query" | json_string)
    echo '  ,{"role": "user", "content": '"$user_input"'}'
    echo ']'
    echo '}'
}

# OpenAI形式のリクエストJSONを生成（エージェントモード）
function _provider_make_request_payload_agent
{
    query=$1
    system=$2

    # 動的にtool定義を読み込む
    local tools
    tools=$(_load_all_tool_definitions_openai)

    echo '{"model": "'$MODEL'", "temperature": '$TEMPERATURE', "tools": '$tools', "messages": ['

    if [ ! -z "$system" ]; then
        echo '  {"role": "system", "content": '"$(echo "$system" | json_string)"'},'
    fi

    local line_count=0
    while IFS= read -r file; do
        if [[ $line_count -gt 0 ]]; then
            echo -n ','
        fi
        line_count=$((line_count + 1))
        if [[ "$file" =~ "_user.txt" ]]; then
            echo '  {"role": "user", "content": '$(cat "$file" | json_string)'}'
        elif [[ "$file" =~ "_tool.txt" ]]; then
            # tool roleの場合は特別な処理
            echo -n '  {"role": "tool", "content": '
            cat "$file"
            echo '}'
        else
            # assistant roleの場合、tool_callsが含まれる可能性がある
            echo -n '  {"role": "assistant", "content": '$(cat "$file" | json_string)'}'
            # tool_callsがある場合は追加（現時点では簡易実装）
        fi
    done

    user_input=$(echo -e "----\n# user message:\n$query" | json_string)
    echo '  ,{"role": "user", "content": '"$user_input"'}'
    echo ']'
    echo '}'
}

# プロバイダ固有: OpenAI APIへのHTTPリクエスト実行
# 引数: request_file - リクエストJSONファイルのパス
# 戻り値: レスポンスJSON文字列（標準出力）
# 終了コード: curlの終了コード（0=成功、非0=エラー）
function _provider_make_http_request
{
    local request_file="$1"
    curl -s -X POST $ENDPOINT \
      -H "Content-Type: application/json" \
      -H "Authorization: Bearer $API_KEY" \
      -d @"$request_file"
}

# プロバイダ固有: レスポンスからテキストを抽出
# 引数: response - レスポンスJSON文字列
# 戻り値: 抽出したテキスト（または "null"）
function _provider_parse_response_text
{
    local response="$1"
    echo "$response" | jq -r '.choices[0].message.content // empty'
}

# プロバイダ固有: tool_callsの有無をチェック
# 引数: response - レスポンスJSON文字列
# 戻り値: "yes" または "no"
function _provider_check_tool_calls
{
    local response="$1"
    echo "$response" | jq -e '.choices[0].message.tool_calls != null and (.choices[0].message.tool_calls | length > 0)' > /dev/null 2>&1 && echo "yes" || echo "no"
}

# プロバイダ固有: tool_callsを処理して更新されたリクエストを返す
# 引数: request_data - 現在のリクエストJSON文字列
#      response - レスポンスJSON文字列
# 戻り値: 更新されたリクエストJSON文字列
function _provider_process_tool_calls
{
    local request_data="$1"
    local response="$2"
    local temp_request="$AISH_SESSION/temp_request_$$.json"
    
    # モデルの応答（tool callsを含む）をmessagesに追加
    assistant_message=$(echo "$response" | jq -c '.choices[0].message')
    if [ -z "$assistant_message" ] || [ "$assistant_message" = "null" ]; then
        echo "$response" >&2
        return 1
    fi
    
    updated_request=$(echo "$request_data" | jq --argjson assistant_msg "$assistant_message" \
        '.messages += [$assistant_msg]')
    
    if [ $? -ne 0 ]; then
        return 1
    fi
    
    # 各tool callを処理してtool responseを収集
    tool_calls=$(echo "$response" | jq -c '.choices[0].message.tool_calls[]')
    
    # 各tool callを処理
    tool_messages="[]"
    while IFS= read -r tool_call; do
        if [ -z "$tool_call" ]; then
            continue
        fi
        tool_call_id=$(echo "$tool_call" | jq -r '.id')
        func_name=$(echo "$tool_call" | jq -r '.function.name')
        func_args=$(echo "$tool_call" | jq -r '.function.arguments')
        
        # 動的にtool実行処理を呼び出す
        result=$(_execute_tool_call "$func_name" "$tool_call_id" "$func_args" "openai")
        execute_exit_code=$?
        
        if [ $execute_exit_code -ne 0 ] || [ -z "$result" ]; then
            # エラーが発生した場合はエラーメッセージを返す
            if [ -z "$result" ]; then
                result='{"error": "Tool execution failed"}'
            fi
            tool_message=$(echo "{}" | jq -c \
                --arg tool_call_id "$tool_call_id" \
                --argjson result "$result" \
                '{role: "tool", tool_call_id: $tool_call_id, content: ($result | tostring)}')
        else
            # tool messageを生成（resultはJSON形式の文字列）
            tool_message=$(echo "{}" | jq -c \
                --arg tool_call_id "$tool_call_id" \
                --argjson result "$result" \
                '{role: "tool", tool_call_id: $tool_call_id, content: ($result | tostring)}')
        fi
        
        if [ $? -ne 0 ]; then
            return 1
        fi
        
        # 配列に追加
        tool_messages=$(echo "$tool_messages" | jq --argjson tool_msg "$tool_message" '. += [$tool_msg]')
    done <<< "$tool_calls"
    
    # すべてのtool messageをmessagesに追加
    echo "$updated_request" | jq --argjson tool_msgs "$tool_messages" \
        '.messages += $tool_msgs'
    
    if [ $? -ne 0 ]; then
        return 1
    fi
}

# プロバイダ固有: APIから利用可能なモデル一覧を取得
# 戻り値: モデル名のリスト（改行区切り）
function _provider_list_available_models
{
    if [ -z "$OPENAI_API_KEY" ]; then
        puts_error "OPENAI_API_KEY is not set"
        return 1
    fi
    
    response=$(curl -s -X GET "https://api.openai.com/v1/models" \
      -H "Authorization: Bearer $OPENAI_API_KEY")
    if [ $? -ne 0 ]; then
        puts_error "Failed to fetch models from OpenAI API"
        return 1
    fi
    
    # エラーレスポンスのチェック
    if echo "$response" | jq -e '.error' > /dev/null 2>&1; then
        error_msg=$(echo "$response" | jq -r '.error.message // .error')
        puts_error "OpenAI API error: $error_msg"
        return 1
    fi
    
    echo "$response" | jq -r '.data[]? | select(.id | startswith("gpt")) | .id' | sort
}

# 共通ライブラリを使用してクエリを実行
function query
{
    _llm_driver_query "$@"
}
