#!/usr/bin/env bash

set -eo pipefail

# OpenAI APIキーを設定
if [ -z "$OPENAI_API_KEY" ];
then
  puts_error "The OPENAI_API_KEY is missing or empty. Please set the API key generated from the OpenAI website."
  exit 1;
fi
API_KEY="$OPENAI_API_KEY"
ENDPOINT="https://api.openai.com/v1/chat/completions"

# 対応しているモデルの一覧
SUPPORTED_MODELS=(
#  "gpt-3.5-turbo"
#  "gpt-4o"
  "gpt-5.2"
)

MODEL="gpt-5.2"
TEMPERATURE=0.7
LOG="$AISH_SESSION"/log.json

# 共通ライブラリを読み込む
. "$AISH_HOME/lib/agent_approve.sh"
. "$AISH_HOME/lib/tool_execute_shell_command.sh"
. "$AISH_HOME/lib/memory_manager.sh"
. "$AISH_HOME/lib/query_entry.sh"
. "$AISH_HOME/lib/llm_driver.sh"

# OpenAI形式のリクエストJSONを生成（通常モード）
function _provider_make_request_payload
{
    query=$1
    system=$2

    echo '{"model": "'$MODEL'", "temperature": '$TEMPERATURE',"messages": ['

    if [ ! -z "$system" ]; then
      echo '  {"role": "system", "content": '"$(echo "$system" | json_string)"'}'
    fi

    local line_count=0
    while IFS= read -r file; do
        if [[ $line_count -gt 0 ]]; then
            echo -n ','
        fi
        line_count=$((line_count + 1))
        if [[ "$file" =~ "_user.txt" ]]; then
            echo '  {"role": "user", "content": '$(cat "$file" | json_string)'}'
        else
            echo '  {"role": "assistant", "content": '$(cat "$file" | json_string)'}'
        fi
    done

    user_input=$(echo -e "----\n# user message:\n$query" | json_string)
    echo '  ,{"role": "user", "content": '"$user_input"'}'
    echo ']'
    echo '}'
}

# OpenAI形式のリクエストJSONを生成（エージェントモード）
function _provider_make_request_payload_agent
{
    query=$1
    system=$2

    local tools='[
        {"type": "function", "function": {"name": "execute_shell_command", "description": "Execute a shell command and return the result with exit code, stdout, and stderr", "parameters": {"type": "object", "properties": {"command": {"type": "string", "description": "The shell command to execute"}}, "required": ["command"]}}},
        {"type": "function", "function": {"name": "save_memory", "description": "Save useful information to the memory system. The memory will be stored in the project-specific directory if .aish/memory exists, otherwise in the global directory.", "parameters": {"type": "object", "properties": {"content": {"type": "string", "description": "The content to remember"}, "category": {"type": "string", "description": "Category: code_pattern, error_solution, workflow, best_practice, configuration, etc.", "default": "general"}, "keywords": {"type": "array", "items": {"type": "string"}, "description": "Keywords for searching this memory later"}}, "required": ["content"]}}},
        {"type": "function", "function": {"name": "search_memory", "description": "Search memories related to the query. Searches both project-specific and global memories.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "Search query"}, "category": {"type": "string", "description": "Filter by category (optional)"}, "limit": {"type": "integer", "description": "Maximum number of results", "default": 5}}, "required": ["query"]}}}
    ]'

    echo '{"model": "'$MODEL'", "temperature": '$TEMPERATURE', "tools": '$tools', "messages": ['

    if [ ! -z "$system" ]; then
        echo '  {"role": "system", "content": '"$(echo "$system" | json_string)"'},'
    fi

    local line_count=0
    while IFS= read -r file; do
        if [[ $line_count -gt 0 ]]; then
            echo -n ','
        fi
        line_count=$((line_count + 1))
        if [[ "$file" =~ "_user.txt" ]]; then
            echo '  {"role": "user", "content": '$(cat "$file" | json_string)'}'
        elif [[ "$file" =~ "_tool.txt" ]]; then
            # tool roleの場合は特別な処理
            echo -n '  {"role": "tool", "content": '
            cat "$file"
            echo '}'
        else
            # assistant roleの場合、tool_callsが含まれる可能性がある
            echo -n '  {"role": "assistant", "content": '$(cat "$file" | json_string)'}'
            # tool_callsがある場合は追加（現時点では簡易実装）
        fi
    done

    user_input=$(echo -e "----\n# user message:\n$query" | json_string)
    echo '  ,{"role": "user", "content": '"$user_input"'}'
    echo ']'
    echo '}'
}

# プロバイダ固有: OpenAI APIへのHTTPリクエスト実行
# 引数: request_file - リクエストJSONファイルのパス
# 戻り値: レスポンスJSON文字列（標準出力）
# 終了コード: curlの終了コード（0=成功、非0=エラー）
function _provider_make_http_request
{
    local request_file="$1"
    curl -s -X POST $ENDPOINT \
      -H "Content-Type: application/json" \
      -H "Authorization: Bearer $API_KEY" \
      -d @"$request_file"
}

# プロバイダ固有: レスポンスからテキストを抽出
# 引数: response - レスポンスJSON文字列
# 戻り値: 抽出したテキスト（または "null"）
function _provider_parse_response_text
{
    local response="$1"
    echo "$response" | jq -r '.choices[0].message.content // empty'
}

# プロバイダ固有: tool_callsの有無をチェック
# 引数: response - レスポンスJSON文字列
# 戻り値: "yes" または "no"
function _provider_check_tool_calls
{
    local response="$1"
    echo "$response" | jq -e '.choices[0].message.tool_calls != null and (.choices[0].message.tool_calls | length > 0)' > /dev/null 2>&1 && echo "yes" || echo "no"
}

# プロバイダ固有: tool_callsを処理して更新されたリクエストを返す
# 引数: request_data - 現在のリクエストJSON文字列
#      response - レスポンスJSON文字列
# 戻り値: 更新されたリクエストJSON文字列
function _provider_process_tool_calls
{
    local request_data="$1"
    local response="$2"
    local temp_request="$AISH_SESSION/temp_request_$$.json"
    
    # モデルの応答（tool callsを含む）をmessagesに追加
    assistant_message=$(echo "$response" | jq -c '.choices[0].message')
    if [ -z "$assistant_message" ] || [ "$assistant_message" = "null" ]; then
        echo "$response" >&2
        return 1
    fi
    
    updated_request=$(echo "$request_data" | jq --argjson assistant_msg "$assistant_message" \
        '.messages += [$assistant_msg]')
    
    if [ $? -ne 0 ]; then
        return 1
    fi
    
    # 各tool callを処理してtool responseを収集
    tool_calls=$(echo "$response" | jq -c '.choices[0].message.tool_calls[]')
    
    # 各tool callを処理
    tool_messages="[]"
    while IFS= read -r tool_call; do
        if [ -z "$tool_call" ]; then
            continue
        fi
        tool_call_id=$(echo "$tool_call" | jq -r '.id')
        func_name=$(echo "$tool_call" | jq -r '.function.name')
        func_args=$(echo "$tool_call" | jq -r '.function.arguments')
        
        if [ "$func_name" = "execute_shell_command" ]; then
            command=$(echo "$func_args" | jq -r '.command')
            
            # シェルコマンドを実行
            result=$(execute_shell_command "$command")
            
            # tool messageを生成
            tool_message=$(echo "{}" | jq -c \
                --arg tool_call_id "$tool_call_id" \
                --argjson result "$result" \
                '{role: "tool", tool_call_id: $tool_call_id, content: ($result | tostring)}')
            
            if [ $? -ne 0 ]; then
                return 1
            fi
            
            # 配列に追加
            tool_messages=$(echo "$tool_messages" | jq --argjson tool_msg "$tool_message" '. += [$tool_msg]')
        elif [ "$func_name" = "save_memory" ]; then
            content=$(echo "$func_args" | jq -r '.content')
            category=$(echo "$func_args" | jq -r '.category // "general"')
            keywords=$(echo "$func_args" | jq -r '.keywords // [] | join(",")')
            
            result=$(save_memory "$content" "$category" "$keywords")
            
            tool_message=$(echo "{}" | jq -c \
                --arg tool_call_id "$tool_call_id" \
                --argjson result "$result" \
                '{role: "tool", tool_call_id: $tool_call_id, content: ($result | tostring)}')
            
            tool_messages=$(echo "$tool_messages" | jq --argjson tool_msg "$tool_message" '. += [$tool_msg]')
        elif [ "$func_name" = "search_memory" ]; then
            query_str=$(echo "$func_args" | jq -r '.query')
            category=$(echo "$func_args" | jq -r '.category // ""')
            limit=$(echo "$func_args" | jq -r '.limit // 5')
            
            result=$(search_memory_efficient "$query_str" "$category" "$limit")
            
            tool_message=$(echo "{}" | jq -c \
                --arg tool_call_id "$tool_call_id" \
                --argjson result "$result" \
                '{role: "tool", tool_call_id: $tool_call_id, content: ($result | tostring)}')
            
            tool_messages=$(echo "$tool_messages" | jq --argjson tool_msg "$tool_message" '. += [$tool_msg]')
        fi
    done <<< "$tool_calls"
    
    # すべてのtool messageをmessagesに追加
    echo "$updated_request" | jq --argjson tool_msgs "$tool_messages" \
        '.messages += $tool_msgs'
    
    if [ $? -ne 0 ]; then
        return 1
    fi
}

# プロバイダ固有: APIから利用可能なモデル一覧を取得
# 戻り値: モデル名のリスト（改行区切り）
function _provider_list_available_models
{
    if [ -z "$OPENAI_API_KEY" ]; then
        puts_error "OPENAI_API_KEY is not set"
        return 1
    fi
    
    response=$(curl -s -X GET "https://api.openai.com/v1/models" \
      -H "Authorization: Bearer $OPENAI_API_KEY")
    if [ $? -ne 0 ]; then
        puts_error "Failed to fetch models from OpenAI API"
        return 1
    fi
    
    # エラーレスポンスのチェック
    if echo "$response" | jq -e '.error' > /dev/null 2>&1; then
        error_msg=$(echo "$response" | jq -r '.error.message // .error')
        puts_error "OpenAI API error: $error_msg"
        return 1
    fi
    
    echo "$response" | jq -r '.data[]? | select(.id | startswith("gpt")) | .id' | sort
}

# 共通ライブラリを使用してクエリを実行
function query
{
    _llm_driver_query "$@"
}
