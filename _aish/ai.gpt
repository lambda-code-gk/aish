#!/usr/bin/env bash

set -eo pipefail

# OpenAI APIã‚­ãƒ¼ã‚’è¨­å®š
if [ -z "$OPENAI_API_KEY" ];
then
  puts_error "The OPENAI_API_KEY is missing or empty. Please set the API key generated from the OpenAI website."
  exit 1;
fi
API_KEY="$OPENAI_API_KEY"
ENDPOINT="https://api.openai.com/v1/chat/completions"
MODEL="gpt-4o"
#MODEL="gpt-3.5-turbo"
TEMPERATURE=0.7
LOG="$AISH_SESSION"/log.json

# ç¢ºèªä¸è¦ãªã‚³ãƒãƒ³ãƒ‰ã®ãƒªã‚¹ãƒˆã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã¿è¾¼ã‚€
# è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«: $AISH_HOME/agent_approved_commands
function get_approved_commands_list
{
  local config_file="$AISH_HOME/agent_approved_commands"
  
  # ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã™ã‚‹å ´åˆã®ã¿èª­ã¿è¾¼ã‚€
  if [ -f "$config_file" ]; then
    cat "$config_file" | grep -v '^#' | grep -v '^$'
  fi
}

# ã‚³ãƒãƒ³ãƒ‰æ–‡å­—åˆ—ã‹ã‚‰å„ã‚³ãƒãƒ³ãƒ‰ã‚’æŠ½å‡ºï¼ˆãƒ‘ã‚¤ãƒ—ã€ã‚»ãƒŸã‚³ãƒ­ãƒ³ã€&&ã€||ã§åˆ†å‰²ï¼‰
# å¼•ç”¨ç¬¦ã§å›²ã¾ã‚ŒãŸéƒ¨åˆ†ã¯ä¿è­·ã™ã‚‹
function extract_commands
{
  local cmd="$1"
  local result=""
  
  # Pythonã‚’ä½¿ã£ã¦å¼•ç”¨ç¬¦ã‚’è€ƒæ…®ã—ãŸãƒ‘ãƒ¼ã‚¹ã‚’è¡Œã†
  python3 -c "
import sys
import re
import shlex

cmd = sys.argv[1]

# å¼•ç”¨ç¬¦ã§å›²ã¾ã‚ŒãŸéƒ¨åˆ†ã‚’ä¿è­·ã—ãªãŒã‚‰ã€ãƒ‘ã‚¤ãƒ—ã€ã‚»ãƒŸã‚³ãƒ­ãƒ³ã€&&ã€||ã§åˆ†å‰²
# ã‚·ãƒ³ãƒ—ãƒ«ãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒ: å¼•ç”¨ç¬¦å¤–ã®ãƒ‘ã‚¤ãƒ—ã€ã‚»ãƒŸã‚³ãƒ­ãƒ³ã€&&ã€||ã§åˆ†å‰²
parts = []
in_quote = False
quote_char = None
current = ''
i = 0

while i < len(cmd):
    char = cmd[i]
    
    if char in ['\"', \"'\"] and (i == 0 or cmd[i-1] != '\\\\'):
        if not in_quote:
            in_quote = True
            quote_char = char
        elif char == quote_char:
            in_quote = False
            quote_char = None
        current += char
    elif not in_quote and char == '|' and (i == 0 or cmd[i-1] != '|') and (i == len(cmd)-1 or cmd[i+1] != '|'):
        # ãƒ‘ã‚¤ãƒ—ï¼ˆ||ã¯é™¤ãï¼‰
        if current.strip():
            parts.append(current.strip())
        current = ''
    elif not in_quote and char == ';':
        # ã‚»ãƒŸã‚³ãƒ­ãƒ³
        if current.strip():
            parts.append(current.strip())
        current = ''
    elif not in_quote and i < len(cmd) - 1 and cmd[i:i+2] == '&&':
        # &&
        if current.strip():
            parts.append(current.strip())
        current = ''
        i += 1
    elif not in_quote and i < len(cmd) - 1 and cmd[i:i+2] == '||':
        # ||
        if current.strip():
            parts.append(current.strip())
        current = ''
        i += 1
    else:
        current += char
    i += 1

if current.strip():
    parts.append(current.strip())

# å„ãƒ‘ãƒ¼ãƒˆã‹ã‚‰ã‚³ãƒãƒ³ãƒ‰åã‚’æŠ½å‡º
for part in parts:
    # ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆè¨˜å·ã‚’é™¤å»
    part = re.sub(r'\\s*\\d*[<>]&?\\s*\\S*', '', part)
    # æœ€åˆã®å˜èªã‚’æŠ½å‡º
    words = part.strip().split()
    if words:
        print(words[0])
" "$cmd" | sort -u
}

# ã‚³ãƒãƒ³ãƒ‰ãŒç¢ºèªä¸è¦ã‹ãƒã‚§ãƒƒã‚¯
function is_command_approved
{
  local command="$1"
  local approved_list=$(get_approved_commands_list)
  
  # ã‚³ãƒãƒ³ãƒ‰æ–‡å­—åˆ—ã‹ã‚‰å„ã‚³ãƒãƒ³ãƒ‰ã‚’æŠ½å‡º
  local commands=$(extract_commands "$command")
  
  # ã™ã¹ã¦ã®ã‚³ãƒãƒ³ãƒ‰ãŒæ‰¿èªãƒªã‚¹ãƒˆã«å«ã¾ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
  local all_approved=true
  while IFS= read -r cmd_name; do
    if [ -z "$cmd_name" ]; then
      continue
    fi
    # ã‚³ãƒãƒ³ãƒ‰åãŒæ‰¿èªãƒªã‚¹ãƒˆã«å«ã¾ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    if ! echo "$approved_list" | grep -Fxq "$cmd_name" 2>/dev/null; then
      all_approved=false
      break
    fi
  done <<< "$commands"
  
  if [ "$all_approved" = true ]; then
    return 0
  else
    return 1
  fi
}

# ã‚·ã‚§ãƒ«ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã—ã€çµæœã‚’JSONå½¢å¼ã§è¿”ã™
function execute_shell_command
{
  command=$1
  
  # æ‰¿èªæ¸ˆã¿ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®ãƒ•ã‚¡ã‚¤ãƒ«
  approved_commands_file="$AISH_SESSION/approved_commands"
  
  # ç¢ºèªä¸è¦ã‚³ãƒãƒ³ãƒ‰ã‹ãƒã‚§ãƒƒã‚¯
  if is_command_approved "$command"; then
    # ç¢ºèªã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¦å®Ÿè¡Œ
    :
  # æ‰¿èªæ¸ˆã¿ã‚³ãƒãƒ³ãƒ‰ã‹ãƒã‚§ãƒƒã‚¯
  elif [ -f "$approved_commands_file" ] && grep -Fxq "$command" "$approved_commands_file" 2>/dev/null; then
    # ç¢ºèªã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¦å®Ÿè¡Œ
    :
  else
    # ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ç¢ºèªã‚’æ±‚ã‚ã‚‹
    echo "" >&2
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" >&2
    echo "ğŸ”§ Agent wants to execute command:" >&2
    echo "   $command" >&2
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" >&2
    echo -n "Execute? ([y]es / [n]o): " >&2
    read -r confirm < /dev/tty
    
    if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
      echo '{"exit_code": 1, "stdout": "", "stderr": "Command execution was cancelled by user"}'
      return 1
    fi
    
    # æ‰¿èªæ¸ˆã¿ãƒªã‚¹ãƒˆã«è¿½åŠ ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ä½œæˆï¼‰
    if [ ! -f "$approved_commands_file" ]; then
      touch "$approved_commands_file"
    fi
    echo "$command" >> "$approved_commands_file"
  fi
  
  # å®Ÿè¡Œã™ã‚‹ã‚³ãƒãƒ³ãƒ‰ã‚’æ¨™æº–ã‚¨ãƒ©ãƒ¼å‡ºåŠ›ã«è¡¨ç¤º
  echo "Executing: $command" >&2
  
  # ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œï¼ˆstdoutã¨stderrã‚’åˆ†é›¢ï¼‰
  stdout_file=$(mktemp "$AISH_SESSION/stdout_XXXXXX")
  stderr_file=$(mktemp "$AISH_SESSION/stderr_XXXXXX")
  
  bash -c "$command" > "$stdout_file" 2> "$stderr_file"
  exit_code=$?
  
  stdout=$(cat "$stdout_file")
  stderr=$(cat "$stderr_file")
  
  rm -f "$stdout_file" "$stderr_file"
  
  # JSONå½¢å¼ã§è¿”ã™
  result="{\"exit_code\": $exit_code, \"stdout\": $(echo "$stdout" | json_string), \"stderr\": $(echo "$stderr" | json_string)}"
  echo "$result"
}

function query
{
    system_instruction=""
    agent_mode=false
    while getopts "s:a" opt; do
        case $opt in
            s) system_instruction=$OPTARG ;;
            a) agent_mode=true ;;
            *)  ;;
        esac
    done
    shift $((OPTIND - 1))

    aish_rollout

    files=$(detail.aish_list_parts | detail.aish_security_check)
    if [ $? -ne 0 ]; then
        exit 1
    fi
    
    if [ "$agent_mode" = true ]; then
        echo -e "$files" | make_request_agent "$*" "$system_instruction" | send_to_llm_agent
    else
        echo -e "$files" | make_request "$*" "$system_instruction" | send_to_llm
    fi
}

function make_request
{
    query=$1
    system=$2

    echo '{"model": "'$MODEL'", "temperature": '$TEMPERATURE',"messages": ['

    if [ ! -z "$system" ]; then
      echo '  {"role": "system", "content": '"$(echo "$system" | json_string)"'}'
    fi

    local line_count=0
    while IFS= read -r file; do
        if [[ $line_count -gt 0 ]]; then
            echo -n ','
        fi
        line_count=$((line_count + 1))
        if [[ "$file" =~ "_user.txt" ]]; then
            echo '  {"role": "user", "content": '$(cat "$file" | json_string)'}'
        else
            echo '  {"role": "assistant", "content": '$(cat "$file" | json_string)'}'
        fi
    done

    user_input=$(echo -e "----\n# user message:\n$query" | json_string)
    echo '  ,{"role": "user", "content": '"$user_input"'}'
    echo ']'
    echo '}'
}

function make_request_agent
{
    query=$1
    system=$2

    echo '{"model": "'$MODEL'", "temperature": '$TEMPERATURE', "tools": [{"type": "function", "function": {"name": "execute_shell_command", "description": "Execute a shell command and return the result with exit code, stdout, and stderr", "parameters": {"type": "object", "properties": {"command": {"type": "string", "description": "The shell command to execute"}}, "required": ["command"]}}}], "messages": ['

    if [ ! -z "$system" ]; then
        echo '  {"role": "system", "content": '"$(echo "$system" | json_string)"'},'
    fi

    local line_count=0
    while IFS= read -r file; do
        if [[ $line_count -gt 0 ]]; then
            echo -n ','
        fi
        line_count=$((line_count + 1))
        if [[ "$file" =~ "_user.txt" ]]; then
            echo '  {"role": "user", "content": '$(cat "$file" | json_string)'}'
        elif [[ "$file" =~ "_tool.txt" ]]; then
            # tool roleã®å ´åˆã¯ç‰¹åˆ¥ãªå‡¦ç†
            echo -n '  {"role": "tool", "content": '
            cat "$file"
            echo '}'
        else
            # assistant roleã®å ´åˆã€tool_callsãŒå«ã¾ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹
            echo -n '  {"role": "assistant", "content": '$(cat "$file" | json_string)'}'
            # tool_callsãŒã‚ã‚‹å ´åˆã¯è¿½åŠ ï¼ˆç¾æ™‚ç‚¹ã§ã¯ç°¡æ˜“å®Ÿè£…ï¼‰
        fi
    done

    user_input=$(echo -e "----\n# user message:\n$query" | json_string)
    echo '  ,{"role": "user", "content": '"$user_input"'}'
    echo ']'
    echo '}'
}

function send_to_llm
{
    REQUEST_FILE="$AISH_SESSION/request.txt"
    cat > "$REQUEST_FILE"
    request_data=$(cat "$REQUEST_FILE")

    detail.aish_log_request "$request_data"

    response=$(curl -s -X POST $ENDPOINT \
      -H "Content-Type: application/json" \
      -H "Authorization: Bearer $API_KEY" \
      -d "$request_data")

    detail.aish_log_response "$response"

    text="$(echo "$response" | jq -r '.choices[0].message.content')"
    if [ "$text" == "null" -o -z "$text" ]; then
        echo "$response"
        exit 1
    fi

    echo "$text" | tee "$AISH_PART/part_$(date +%Y%m%d_%H%M%S)_assistant.txt"
    echo "$text" | detail.aish_pickup_codeblock
}

function send_to_llm_agent
{
    REQUEST_FILE="$AISH_SESSION/request.txt"
    MAX_ITERATIONS=20
    iteration=0
    
    # åˆæœŸãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ä¿å­˜
    cat > $REQUEST_FILE
    
    while [ $iteration -lt $MAX_ITERATIONS ]; do
        iteration=$((iteration + 1))
        request_data=$(cat "$REQUEST_FILE")

        detail.aish_log_request "$request_data"

        response=$(curl -s -X POST $ENDPOINT \
          -H "Content-Type: application/json" \
          -H "Authorization: Bearer $API_KEY" \
          -d "$request_data")
        
        curl_exit_code=$?
        if [ $curl_exit_code -ne 0 ]; then
            echo "$response" >&2
            exit 1
        fi

        detail.aish_log_response "$response"

        # ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯
        error=$(echo "$response" | jq -r '.error.message // empty' 2>/dev/null)
        if [ ! -z "$error" ]; then
            echo "$response" >&2
            exit 1
        fi

        # tool_callsã‚’ãƒã‚§ãƒƒã‚¯
        has_tool_calls=$(echo "$response" | jq -e '.choices[0].message.tool_calls != null and (.choices[0].message.tool_calls | length > 0)' > /dev/null 2>&1 && echo "yes" || echo "no")
        
        if [ "$has_tool_calls" = "yes" ]; then
            # tool callãŒã‚ã‚‹å ´åˆã€å„tool callã‚’å‡¦ç†
            temp_request="$AISH_SESSION/temp_request_$$.json"
            
            # ãƒ¢ãƒ‡ãƒ«ã®å¿œç­”ï¼ˆtool callsã‚’å«ã‚€ï¼‰ã‚’messagesã«è¿½åŠ 
            assistant_message=$(echo "$response" | jq -c '.choices[0].message')
            if [ -z "$assistant_message" ] || [ "$assistant_message" = "null" ]; then
                echo "$response" >&2
                exit 1
            fi
            
            updated_request=$(echo "$request_data" | jq --argjson assistant_msg "$assistant_message" \
                '.messages += [$assistant_msg]')
            
            if [ $? -ne 0 ]; then
                exit 1
            fi
            
            # å„tool callã‚’å‡¦ç†ã—ã¦tool responseã‚’åé›†
            tool_calls=$(echo "$response" | jq -c '.choices[0].message.tool_calls[]')
            
            # å„tool callã‚’å‡¦ç†
            tool_messages="[]"
            while IFS= read -r tool_call; do
                if [ -z "$tool_call" ]; then
                    continue
                fi
                tool_call_id=$(echo "$tool_call" | jq -r '.id')
                func_name=$(echo "$tool_call" | jq -r '.function.name')
                func_args=$(echo "$tool_call" | jq -r '.function.arguments')
                
                if [ "$func_name" = "execute_shell_command" ]; then
                    command=$(echo "$func_args" | jq -r '.command')
                    
                    # ã‚·ã‚§ãƒ«ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œ
                    result=$(execute_shell_command "$command")
                    
                    # tool messageã‚’ç”Ÿæˆ
                    tool_message=$(echo "{}" | jq -c \
                        --arg tool_call_id "$tool_call_id" \
                        --argjson result "$result" \
                        '{role: "tool", tool_call_id: $tool_call_id, content: ($result | tostring)}')
                    
                    if [ $? -ne 0 ]; then
                        exit 1
                    fi
                    
                    # é…åˆ—ã«è¿½åŠ 
                    tool_messages=$(echo "$tool_messages" | jq --argjson tool_msg "$tool_message" '. += [$tool_msg]')
                fi
            done <<< "$tool_calls"
            
            # ã™ã¹ã¦ã®tool messageã‚’messagesã«è¿½åŠ 
            echo "$updated_request" | jq --argjson tool_msgs "$tool_messages" \
                '.messages += $tool_msgs' > "$temp_request"
            
            if [ $? -ne 0 ]; then
                exit 1
            fi
            
            mv "$temp_request" "$REQUEST_FILE"
            
            # æ¬¡ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã«é€²ã‚€
            continue
        else
            # tool callãŒãªã„å ´åˆã€ãƒ†ã‚­ã‚¹ãƒˆå¿œç­”ã‚’è¿”ã—ã¦çµ‚äº†
            text="$(echo "$response" | jq -r '.choices[0].message.content // empty')"
            
            if [ "$text" == "null" -o -z "$text" ]; then
                echo "$response" >&2
                exit 1
            fi

            echo "$text" | tee "$AISH_PART/part_$(date +%Y%m%d_%H%M%S)_assistant.txt"
            echo "$text" | detail.aish_pickup_codeblock
            return 0
        fi
    done
    
    echo "Error: Maximum iterations ($MAX_ITERATIONS) reached" >&2
    exit 1
}
