#!/usr/bin/env bash

set -eo pipefail

# OpenAI APIキーを設定
if [ -z "$OPENAI_API_KEY" ];
then
  puts_error "The OPENAI_API_KEY is missing or empty. Please set the API key generated from the OpenAI website."
  exit 1;
fi
API_KEY="$OPENAI_API_KEY"
ENDPOINT="https://api.openai.com/v1/chat/completions"
#MODEL="gpt-3.5-turbo"
#MODEL="gpt-4o"
MODEL="gpt-5.2"
TEMPERATURE=0.7
LOG="$AISH_SESSION"/log.json

# 共通ライブラリを読み込む
. "$AISH_HOME/lib/agent_approve.sh"
. "$AISH_HOME/lib/tool_execute_shell_command.sh"
. "$AISH_HOME/lib/query_entry.sh"

function query
{
    query_entry_prepare "$@"
    
    if [ "$_query_agent_mode" = true ]; then
        echo -e "$_query_files" | make_request_agent "$_query_args" "$_query_system_instruction" | send_to_llm_agent
    else
        echo -e "$_query_files" | make_request "$_query_args" "$_query_system_instruction" | send_to_llm
    fi
}

function make_request
{
    query=$1
    system=$2

    echo '{"model": "'$MODEL'", "temperature": '$TEMPERATURE',"messages": ['

    if [ ! -z "$system" ]; then
      echo '  {"role": "system", "content": '"$(echo "$system" | json_string)"'}'
    fi

    local line_count=0
    while IFS= read -r file; do
        if [[ $line_count -gt 0 ]]; then
            echo -n ','
        fi
        line_count=$((line_count + 1))
        if [[ "$file" =~ "_user.txt" ]]; then
            echo '  {"role": "user", "content": '$(cat "$file" | json_string)'}'
        else
            echo '  {"role": "assistant", "content": '$(cat "$file" | json_string)'}'
        fi
    done

    user_input=$(echo -e "----\n# user message:\n$query" | json_string)
    echo '  ,{"role": "user", "content": '"$user_input"'}'
    echo ']'
    echo '}'
}

function make_request_agent
{
    query=$1
    system=$2

    echo '{"model": "'$MODEL'", "temperature": '$TEMPERATURE', "tools": [{"type": "function", "function": {"name": "execute_shell_command", "description": "Execute a shell command and return the result with exit code, stdout, and stderr", "parameters": {"type": "object", "properties": {"command": {"type": "string", "description": "The shell command to execute"}}, "required": ["command"]}}}], "messages": ['

    if [ ! -z "$system" ]; then
        echo '  {"role": "system", "content": '"$(echo "$system" | json_string)"'},'
    fi

    local line_count=0
    while IFS= read -r file; do
        if [[ $line_count -gt 0 ]]; then
            echo -n ','
        fi
        line_count=$((line_count + 1))
        if [[ "$file" =~ "_user.txt" ]]; then
            echo '  {"role": "user", "content": '$(cat "$file" | json_string)'}'
        elif [[ "$file" =~ "_tool.txt" ]]; then
            # tool roleの場合は特別な処理
            echo -n '  {"role": "tool", "content": '
            cat "$file"
            echo '}'
        else
            # assistant roleの場合、tool_callsが含まれる可能性がある
            echo -n '  {"role": "assistant", "content": '$(cat "$file" | json_string)'}'
            # tool_callsがある場合は追加（現時点では簡易実装）
        fi
    done

    user_input=$(echo -e "----\n# user message:\n$query" | json_string)
    echo '  ,{"role": "user", "content": '"$user_input"'}'
    echo ']'
    echo '}'
}

function send_to_llm
{
    REQUEST_FILE="$AISH_SESSION/request.txt"
    cat > "$REQUEST_FILE"
    request_data=$(cat "$REQUEST_FILE")

    detail.aish_log_request "$request_data"

    response=$(curl -s -X POST $ENDPOINT \
      -H "Content-Type: application/json" \
      -H "Authorization: Bearer $API_KEY" \
      -d "$request_data")

    detail.aish_log_response "$response"

    text="$(echo "$response" | jq -r '.choices[0].message.content')"
    if [ "$text" == "null" -o -z "$text" ]; then
        echo "$response"
        exit 1
    fi

    save_response_text "$text"
}

function send_to_llm_agent
{
    REQUEST_FILE="$AISH_SESSION/request.txt"
    MAX_ITERATIONS=20
    iteration=0
    
    # 初期リクエストを保存
    cat > $REQUEST_FILE
    
    while [ $iteration -lt $MAX_ITERATIONS ]; do
        iteration=$((iteration + 1))
        request_data=$(cat "$REQUEST_FILE")

        detail.aish_log_request "$request_data"

        response=$(curl -s -X POST $ENDPOINT \
          -H "Content-Type: application/json" \
          -H "Authorization: Bearer $API_KEY" \
          -d "$request_data")
        
        curl_exit_code=$?
        if [ $curl_exit_code -ne 0 ]; then
            echo "$response" >&2
            exit 1
        fi

        detail.aish_log_response "$response"

        # エラーチェック
        error=$(echo "$response" | jq -r '.error.message // empty' 2>/dev/null)
        if [ ! -z "$error" ]; then
            echo "$response" >&2
            exit 1
        fi

        # tool_callsをチェック
        has_tool_calls=$(echo "$response" | jq -e '.choices[0].message.tool_calls != null and (.choices[0].message.tool_calls | length > 0)' > /dev/null 2>&1 && echo "yes" || echo "no")
        
        if [ "$has_tool_calls" = "yes" ]; then
            # tool callがある場合、各tool callを処理
            temp_request="$AISH_SESSION/temp_request_$$.json"
            
            # モデルの応答（tool callsを含む）をmessagesに追加
            assistant_message=$(echo "$response" | jq -c '.choices[0].message')
            if [ -z "$assistant_message" ] || [ "$assistant_message" = "null" ]; then
                echo "$response" >&2
                exit 1
            fi
            
            updated_request=$(echo "$request_data" | jq --argjson assistant_msg "$assistant_message" \
                '.messages += [$assistant_msg]')
            
            if [ $? -ne 0 ]; then
                exit 1
            fi
            
            # 各tool callを処理してtool responseを収集
            tool_calls=$(echo "$response" | jq -c '.choices[0].message.tool_calls[]')
            
            # 各tool callを処理
            tool_messages="[]"
            while IFS= read -r tool_call; do
                if [ -z "$tool_call" ]; then
                    continue
                fi
                tool_call_id=$(echo "$tool_call" | jq -r '.id')
                func_name=$(echo "$tool_call" | jq -r '.function.name')
                func_args=$(echo "$tool_call" | jq -r '.function.arguments')
                
                if [ "$func_name" = "execute_shell_command" ]; then
                    command=$(echo "$func_args" | jq -r '.command')
                    
                    # シェルコマンドを実行
                    result=$(execute_shell_command "$command")
                    
                    # tool messageを生成
                    tool_message=$(echo "{}" | jq -c \
                        --arg tool_call_id "$tool_call_id" \
                        --argjson result "$result" \
                        '{role: "tool", tool_call_id: $tool_call_id, content: ($result | tostring)}')
                    
                    if [ $? -ne 0 ]; then
                        exit 1
                    fi
                    
                    # 配列に追加
                    tool_messages=$(echo "$tool_messages" | jq --argjson tool_msg "$tool_message" '. += [$tool_msg]')
                fi
            done <<< "$tool_calls"
            
            # すべてのtool messageをmessagesに追加
            echo "$updated_request" | jq --argjson tool_msgs "$tool_messages" \
                '.messages += $tool_msgs' > "$temp_request"
            
            if [ $? -ne 0 ]; then
                exit 1
            fi
            
            mv "$temp_request" "$REQUEST_FILE"
            
            # 次のイテレーションに進む
            continue
        else
            # tool callがない場合、テキスト応答を返して終了
            text="$(echo "$response" | jq -r '.choices[0].message.content // empty')"
            
            if [ "$text" == "null" -o -z "$text" ]; then
                echo "$response" >&2
                exit 1
            fi

            save_response_text "$text"
            return 0
        fi
    done
    
    echo "Error: Maximum iterations ($MAX_ITERATIONS) reached" >&2
    exit 1
}
