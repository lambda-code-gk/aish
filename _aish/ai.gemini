#!/usr/bin/env bash

set -eo pipefail

#MODEL="gemini-1.5-flash"
#MODEL="gemini-1.5-pro"
#MODEL="gemini-2.0-flash-exp"
#MODEL="gemini-2.0-flash"
#MODEL="gemini-2.5-pro-preview-03-25"
#MODEL="gemini-2.5-flash-preview-04-17"
#MODEL="gemini-2.5-pro-preview-05-06"
#MODEL="gemini-2.5-flash-preview-05-20"
#MODEL="gemini-2.5-flash-preview-05-20"
MODEL="gemini-3-flash-preview"

LOG="$AISH_SESSION"/log.json

# ç¢ºèªä¸è¦ãªã‚³ãƒãƒ³ãƒ‰ã®ãƒªã‚¹ãƒˆã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã¿è¾¼ã‚€
# è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«: $AISH_HOME/agent_approved_commands
function get_approved_commands_list
{
  local config_file="$AISH_HOME/agent_approved_commands"
  
  # ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã™ã‚‹å ´åˆã®ã¿èª­ã¿è¾¼ã‚€
  if [ -f "$config_file" ]; then
    cat "$config_file" | grep -v '^#' | grep -v '^$'
  fi
}

# ã‚³ãƒãƒ³ãƒ‰æ–‡å­—åˆ—ã‹ã‚‰å„ã‚³ãƒãƒ³ãƒ‰ã‚’æŠ½å‡ºï¼ˆãƒ‘ã‚¤ãƒ—ã€ã‚»ãƒŸã‚³ãƒ­ãƒ³ã€&&ã€||ã§åˆ†å‰²ï¼‰
# å¼•ç”¨ç¬¦ã§å›²ã¾ã‚ŒãŸéƒ¨åˆ†ã¯ä¿è­·ã™ã‚‹
function extract_commands
{
  local cmd="$1"
  local result=""
  
  # Pythonã‚’ä½¿ã£ã¦å¼•ç”¨ç¬¦ã‚’è€ƒæ…®ã—ãŸãƒ‘ãƒ¼ã‚¹ã‚’è¡Œã†
  python3 -c "
import sys
import re
import shlex

cmd = sys.argv[1]

# å¼•ç”¨ç¬¦ã§å›²ã¾ã‚ŒãŸéƒ¨åˆ†ã‚’ä¿è­·ã—ãªãŒã‚‰ã€ãƒ‘ã‚¤ãƒ—ã€ã‚»ãƒŸã‚³ãƒ­ãƒ³ã€&&ã€||ã§åˆ†å‰²
# ã‚·ãƒ³ãƒ—ãƒ«ãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒ: å¼•ç”¨ç¬¦å¤–ã®ãƒ‘ã‚¤ãƒ—ã€ã‚»ãƒŸã‚³ãƒ­ãƒ³ã€&&ã€||ã§åˆ†å‰²
parts = []
in_quote = False
quote_char = None
current = ''
i = 0

while i < len(cmd):
    char = cmd[i]
    
    if char in ['\"', \"'\"] and (i == 0 or cmd[i-1] != '\\\\'):
        if not in_quote:
            in_quote = True
            quote_char = char
        elif char == quote_char:
            in_quote = False
            quote_char = None
        current += char
    elif not in_quote and char == '|' and (i == 0 or cmd[i-1] != '|') and (i == len(cmd)-1 or cmd[i+1] != '|'):
        # ãƒ‘ã‚¤ãƒ—ï¼ˆ||ã¯é™¤ãï¼‰
        if current.strip():
            parts.append(current.strip())
        current = ''
    elif not in_quote and char == ';':
        # ã‚»ãƒŸã‚³ãƒ­ãƒ³
        if current.strip():
            parts.append(current.strip())
        current = ''
    elif not in_quote and i < len(cmd) - 1 and cmd[i:i+2] == '&&':
        # &&
        if current.strip():
            parts.append(current.strip())
        current = ''
        i += 1
    elif not in_quote and i < len(cmd) - 1 and cmd[i:i+2] == '||':
        # ||
        if current.strip():
            parts.append(current.strip())
        current = ''
        i += 1
    else:
        current += char
    i += 1

if current.strip():
    parts.append(current.strip())

# å„ãƒ‘ãƒ¼ãƒˆã‹ã‚‰ã‚³ãƒãƒ³ãƒ‰åã‚’æŠ½å‡º
for part in parts:
    # ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆè¨˜å·ã‚’é™¤å»
    part = re.sub(r'\\s*\\d*[<>]&?\\s*\\S*', '', part)
    # æœ€åˆã®å˜èªã‚’æŠ½å‡º
    words = part.strip().split()
    if words:
        print(words[0])
" "$cmd" | sort -u
}

# ã‚³ãƒãƒ³ãƒ‰ãŒç¢ºèªä¸è¦ã‹ãƒã‚§ãƒƒã‚¯
function is_command_approved
{
  local command="$1"
  local approved_list=$(get_approved_commands_list)
  
  # ã‚³ãƒãƒ³ãƒ‰æ–‡å­—åˆ—ã‹ã‚‰å„ã‚³ãƒãƒ³ãƒ‰ã‚’æŠ½å‡º
  local commands=$(extract_commands "$command")
  
  # ã™ã¹ã¦ã®ã‚³ãƒãƒ³ãƒ‰ãŒæ‰¿èªãƒªã‚¹ãƒˆã«å«ã¾ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
  local all_approved=true
  while IFS= read -r cmd_name; do
    if [ -z "$cmd_name" ]; then
      continue
    fi
    # ã‚³ãƒãƒ³ãƒ‰åãŒæ‰¿èªãƒªã‚¹ãƒˆã«å«ã¾ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    if ! echo "$approved_list" | grep -Fxq "$cmd_name" 2>/dev/null; then
      all_approved=false
      break
    fi
  done <<< "$commands"
  
  if [ "$all_approved" = true ]; then
    return 0
  else
    return 1
  fi
}

# ã‚·ã‚§ãƒ«ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã—ã€çµæœã‚’JSONå½¢å¼ã§è¿”ã™
function execute_shell_command
{
  command=$1
  
  # æ‰¿èªæ¸ˆã¿ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®ãƒ•ã‚¡ã‚¤ãƒ«
  approved_commands_file="$AISH_SESSION/approved_commands"
  
  # ç¢ºèªä¸è¦ã‚³ãƒãƒ³ãƒ‰ã‹ãƒã‚§ãƒƒã‚¯
  if is_command_approved "$command"; then
    # ç¢ºèªã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¦å®Ÿè¡Œ
    :
  # æ‰¿èªæ¸ˆã¿ã‚³ãƒãƒ³ãƒ‰ã‹ãƒã‚§ãƒƒã‚¯
  elif [ -f "$approved_commands_file" ] && grep -Fxq "$command" "$approved_commands_file" 2>/dev/null; then
    # ç¢ºèªã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¦å®Ÿè¡Œ
    :
  else
    # ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ç¢ºèªã‚’æ±‚ã‚ã‚‹
    echo "" >&2
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" >&2
    echo "ğŸ”§ Agent wants to execute command:" >&2
    echo "   $command" >&2
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" >&2
    echo -n "Execute? ([y]es / [n]o): " >&2
    read -r confirm < /dev/tty
    
    if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
      echo '{"exit_code": 1, "stdout": "", "stderr": "Command execution was cancelled by user"}'
      return 1
    fi
    
    # æ‰¿èªæ¸ˆã¿ãƒªã‚¹ãƒˆã«è¿½åŠ ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ä½œæˆï¼‰
    if [ ! -f "$approved_commands_file" ]; then
      touch "$approved_commands_file"
    fi
    echo "$command" >> "$approved_commands_file"
  fi
  
  # å®Ÿè¡Œã™ã‚‹ã‚³ãƒãƒ³ãƒ‰ã‚’æ¨™æº–ã‚¨ãƒ©ãƒ¼å‡ºåŠ›ã«è¡¨ç¤º
  echo "Executing: $command" >&2
  
  # ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œï¼ˆstdoutã¨stderrã‚’åˆ†é›¢ï¼‰
  stdout_file=$(mktemp "$AISH_SESSION/stdout_XXXXXX")
  stderr_file=$(mktemp "$AISH_SESSION/stderr_XXXXXX")
  
  bash -c "$command" > "$stdout_file" 2> "$stderr_file"
  exit_code=$?
  
  stdout=$(cat "$stdout_file")
  stderr=$(cat "$stderr_file")
  
  rm -f "$stdout_file" "$stderr_file"
  
  # JSONå½¢å¼ã§è¿”ã™
  result="{\"exit_code\": $exit_code, \"stdout\": $(echo "$stdout" | json_string), \"stderr\": $(echo "$stderr" | json_string)}"
  echo "$result"
}

function query
{
  system_instruction=""
  agent_mode=false
  while getopts "s:a" opt; do
    case $opt in
      s) system_instruction=$OPTARG ;;
      a) agent_mode=true ;;
      *)  ;;
    esac
  done
  shift $((OPTIND - 1))

  aish_rollout

  files=$(detail.aish_list_parts | detail.aish_security_check)
  if [ $? -ne 0 ]; then
      exit 1
  fi
  
  if [ "$agent_mode" = true ]; then
    echo -e "$files" | make_request_agent "$*" "$system_instruction" | send_to_llm_agent
  else
    echo -e "$files" | make_request "$*" "$system_instruction" | send_to_llm
  fi
}

function make_request
{
  query=$1
  system=$2

  echo '{'

  if [ ! -z "$system" ];
  then
    echo '"system_instruction": {"parts": {"text": '$(echo "$system" | json_string)'}},'
  fi


  echo '"contents":['

  while IFS= read -r file; do
    if [[ "$file" =~ "_user.txt" ]]; then
      role="user"
    else
      role="model"
    fi
    echo -n '  {"role": "'$role'", "parts":[{"text": '
    cat "$file" | json_string
    echo '}]},'
  done
  user_input=$(echo -e "----\n# user message:\n$query" | json_string)
  echo '  {"role": "user", "parts":[{"text": '"$user_input"'}]}'
  echo ']'
  echo '}'
}

function send_to_llm
{
  REQUEST_FILE="$AISH_SESSION/request.txt"
  cat > $REQUEST_FILE
  request_data=$(cat "$REQUEST_FILE")

  detail.aish_log_request "$request_data"

  response=$(curl -s https://generativelanguage.googleapis.com/v1beta/models/"$MODEL":generateContent?key="$GEMINI_API_KEY" \
    -H 'Content-Type: application/json' \
    -X POST \
    --data-binary @${REQUEST_FILE})

  detail.aish_log_response "$response"

  text="$(echo "$response" | jq -r '.candidates[0].content.parts[0].text')"

  if [ "$text" == "null" -o -z "$text" ];
  then
    echo "$response"
    exit 1
  fi

  echo "$text" | tee "$AISH_PART/part_$(date +%Y%m%d_%H%M%S)_assistant.txt"
  echo "$text" | detail.aish_pickup_codeblock
}

function make_request_agent
{
  query=$1
  system=$2

  echo '{'

  if [ ! -z "$system" ];
  then
    echo '"system_instruction": {"parts": {"text": '$(echo "$system" | json_string)'}},'
  fi

  echo '"tools": [{"functionDeclarations": [{"name": "execute_shell_command", "description": "Execute a shell command and return the result with exit code, stdout, and stderr", "parameters": {"type": "object", "properties": {"command": {"type": "string", "description": "The shell command to execute"}}, "required": ["command"]}}]}],'

  echo '"contents":['

  while IFS= read -r file; do
    if [[ "$file" =~ "_user.txt" ]]; then
      role="user"
    elif [[ "$file" =~ "_function.txt" ]]; then
      role="function"
    else
      role="model"
    fi
    
    # function roleã®å ´åˆã¯ç‰¹åˆ¥ãªå‡¦ç†
    if [ "$role" = "function" ]; then
      # function responseå½¢å¼ã§å‡ºåŠ›
      echo -n '  {"role": "function", "parts":['
      cat "$file"
      echo ']},'
    else
      echo -n '  {"role": "'$role'", "parts":[{"text": '
      cat "$file" | json_string
      echo '}]},'
    fi
  done
  user_input=$(echo -e "----\n# user message:\n$query" | json_string)
  echo '  {"role": "user", "parts":[{"text": '"$user_input"'}]}'
  echo ']'
  echo '}'
}

function send_to_llm_agent
{
  REQUEST_FILE="$AISH_SESSION/request.txt"
  MAX_ITERATIONS=20
  iteration=0
  
  # åˆæœŸãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ä¿å­˜
  cat > $REQUEST_FILE
  
  while [ $iteration -lt $MAX_ITERATIONS ]; do
    iteration=$((iteration + 1))
    request_data=$(cat "$REQUEST_FILE")

    detail.aish_log_request "$request_data"

    response=$(curl -s https://generativelanguage.googleapis.com/v1beta/models/"$MODEL":generateContent?key="$GEMINI_API_KEY" \
      -H 'Content-Type: application/json' \
      -X POST \
      --data-binary @${REQUEST_FILE})
    
    curl_exit_code=$?
    if [ $curl_exit_code -ne 0 ]; then
      echo "$response" >&2
      exit 1
    fi

    detail.aish_log_response "$response"

    # ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯
    error=$(echo "$response" | jq -r '.error.message // empty' 2>/dev/null)
    if [ ! -z "$error" ]; then
      echo "$response" >&2
      exit 1
    fi

    # functionCallsã‚’ãƒã‚§ãƒƒã‚¯
    has_function_calls=$(echo "$response" | jq -e '.candidates[0].content.parts[] | select(.functionCall != null)' > /dev/null 2>&1 && echo "yes" || echo "no")
    
    if [ "$has_function_calls" = "yes" ]; then
      # function callãŒã‚ã‚‹å ´åˆã€å„function callã‚’å‡¦ç†
      temp_request="$AISH_SESSION/temp_request_$$.json"
      
      # ãƒ¢ãƒ‡ãƒ«ã®å¿œç­”ï¼ˆfunction callã‚’å«ã‚€ï¼‰ã‚’contentsã«è¿½åŠ 
      model_parts=$(echo "$response" | jq -c '.candidates[0].content.parts')
      if [ -z "$model_parts" ] || [ "$model_parts" = "null" ]; then
        echo "$response" >&2
        exit 1
      fi
      
      updated_request=$(echo "$request_data" | jq --argjson model_parts "$model_parts" \
        '.contents += [{"role": "model", "parts": $model_parts}]')
      
      if [ $? -ne 0 ]; then
        exit 1
      fi
      
      # å„function callã‚’å‡¦ç†ã—ã¦function responseã‚’åé›†
      func_responses_file="$AISH_SESSION/func_responses_$$.json"
      echo "[]" > "$func_responses_file"
      
      # function callã®ãƒªã‚¹ãƒˆã‚’ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
      func_calls_file="$AISH_SESSION/func_calls_$$.json"
      echo "$response" | jq -c '.candidates[0].content.parts[] | select(.functionCall != null) | .functionCall' > "$func_calls_file"
      
      # å„function callã‚’å‡¦ç†
      while IFS= read -r func_call; do
        if [ -z "$func_call" ]; then
          continue
        fi
        func_name=$(echo "$func_call" | jq -r '.name')
        func_args=$(echo "$func_call" | jq -r '.args')
        
        if [ "$func_name" = "execute_shell_command" ]; then
          command=$(echo "$func_args" | jq -r '.command')
          
          # ã‚·ã‚§ãƒ«ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œ
          result=$(execute_shell_command "$command")
          
          # function responseã‚’ç”Ÿæˆ
          func_response=$(echo "$result" | jq -c '{functionResponse: {name: "execute_shell_command", response: .}}')
          if [ $? -ne 0 ]; then
            exit 1
          fi
          
          # é…åˆ—ã«è¿½åŠ 
          echo "$(cat "$func_responses_file")" | jq --argjson func_res "$func_response" '. += [$func_res]' > "${func_responses_file}.new"
          if [ $? -ne 0 ]; then
            exit 1
          fi
          mv "${func_responses_file}.new" "$func_responses_file"
        fi
      done < "$func_calls_file"
      
      # ã™ã¹ã¦ã®function responseã‚’contentsã«è¿½åŠ 
      func_responses=$(cat "$func_responses_file")
      echo "$updated_request" | jq --argjson func_responses "$func_responses" \
        '.contents += ($func_responses | map({"role": "function", "parts": [.]}))' > "$temp_request"
      
      if [ $? -ne 0 ]; then
        exit 1
      fi
      
      mv "$temp_request" "$REQUEST_FILE"
      rm -f "$func_responses_file" "$func_calls_file"
      
      # æ¬¡ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã«é€²ã‚€
      continue
    else
      # function callãŒãªã„å ´åˆã€ãƒ†ã‚­ã‚¹ãƒˆå¿œç­”ã‚’è¿”ã—ã¦çµ‚äº†
      # ã™ã¹ã¦ã®ãƒ†ã‚­ã‚¹ãƒˆãƒ‘ãƒ¼ãƒˆã‚’çµåˆ
      text="$(echo "$response" | jq -r '[.candidates[0].content.parts[]? | select(.text != null) | .text] | join("")')"
      
      if [ "$text" == "null" -o -z "$text" ]; then
        echo "$response" >&2
        exit 1
      fi

      echo "$text" | tee "$AISH_PART/part_$(date +%Y%m%d_%H%M%S)_assistant.txt"
      echo "$text" | detail.aish_pickup_codeblock
      return 0
    fi
  done
  
  echo "Error: Maximum iterations ($MAX_ITERATIONS) reached" >&2
  exit 1
}
