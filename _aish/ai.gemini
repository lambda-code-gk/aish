#!/usr/bin/env bash

set -eo pipefail

#MODEL="gemini-1.5-flash"
#MODEL="gemini-1.5-pro"
#MODEL="gemini-2.0-flash-exp"
#MODEL="gemini-2.0-flash"
#MODEL="gemini-2.5-pro-preview-03-25"
#MODEL="gemini-2.5-flash-preview-04-17"
#MODEL="gemini-2.5-pro-preview-05-06"
#MODEL="gemini-2.5-flash-preview-05-20"
#MODEL="gemini-2.5-flash-preview-05-20"
MODEL="gemini-3-flash-preview"

LOG="$AISH_SESSION"/log.json

# 共通ライブラリを読み込む
. "$AISH_HOME/lib/agent_approve.sh"
. "$AISH_HOME/lib/tool_execute_shell_command.sh"
. "$AISH_HOME/lib/query_entry.sh"
. "$AISH_HOME/lib/llm_driver.sh"

# Gemini形式のリクエストJSONを生成（通常モード）
function _provider_make_request_payload
{
  query=$1
  system=$2

  echo '{'

  if [ ! -z "$system" ];
  then
    echo '"system_instruction": {"parts": {"text": '$(echo "$system" | json_string)'}},'
  fi


  echo '"contents":['

  while IFS= read -r file; do
    if [[ "$file" =~ "_user.txt" ]]; then
      role="user"
    else
      role="model"
    fi
    echo -n '  {"role": "'$role'", "parts":[{"text": '
    cat "$file" | json_string
    echo '}]},'
  done
  user_input=$(echo -e "----\n# user message:\n$query" | json_string)
  echo '  {"role": "user", "parts":[{"text": '"$user_input"'}]}'
  echo ']'
  echo '}'
}

# Gemini形式のリクエストJSONを生成（エージェントモード）
function _provider_make_request_payload_agent
{
  query=$1
  system=$2

  echo '{'

  if [ ! -z "$system" ];
  then
    echo '"system_instruction": {"parts": {"text": '$(echo "$system" | json_string)'}},'
  fi

  echo '"tools": [{"functionDeclarations": [{"name": "execute_shell_command", "description": "Execute a shell command and return the result with exit code, stdout, and stderr", "parameters": {"type": "object", "properties": {"command": {"type": "string", "description": "The shell command to execute"}}, "required": ["command"]}}]}],'

  echo '"contents":['

  while IFS= read -r file; do
    if [[ "$file" =~ "_user.txt" ]]; then
      role="user"
    elif [[ "$file" =~ "_function.txt" ]]; then
      role="function"
    else
      role="model"
    fi
    
    # function roleの場合は特別な処理
    if [ "$role" = "function" ]; then
      # function response形式で出力
      echo -n '  {"role": "function", "parts":['
      cat "$file"
      echo ']},'
    else
      echo -n '  {"role": "'$role'", "parts":[{"text": '
      cat "$file" | json_string
      echo '}]},'
    fi
  done
  user_input=$(echo -e "----\n# user message:\n$query" | json_string)
  echo '  {"role": "user", "parts":[{"text": '"$user_input"'}]}'
  echo ']'
  echo '}'
}

# プロバイダ固有: Gemini APIへのHTTPリクエスト実行
# 引数: request_file - リクエストJSONファイルのパス
# 戻り値: レスポンスJSON文字列（標準出力）
# 終了コード: curlの終了コード（0=成功、非0=エラー）
function _provider_make_http_request
{
    local request_file="$1"
    curl -s "https://generativelanguage.googleapis.com/v1beta/models/${MODEL}:generateContent?key=${GEMINI_API_KEY}" \
      -H 'Content-Type: application/json' \
      -X POST \
      --data-binary @"$request_file"
}

# プロバイダ固有: レスポンスからテキストを抽出
# 引数: response - レスポンスJSON文字列
# 戻り値: 抽出したテキスト（または "null"）
function _provider_parse_response_text
{
    local response="$1"
    echo "$response" | jq -r '[.candidates[0].content.parts[]? | select(.text != null) | .text] | join("") // empty'
}

# プロバイダ固有: functionCallの有無をチェック
# 引数: response - レスポンスJSON文字列
# 戻り値: "yes" または "no"
function _provider_check_tool_calls
{
    local response="$1"
    echo "$response" | jq -e '.candidates[0].content.parts[] | select(.functionCall != null)' > /dev/null 2>&1 && echo "yes" || echo "no"
}

# プロバイダ固有: functionCallを処理して更新されたリクエストを返す
# 引数: request_data - 現在のリクエストJSON文字列
#      response - レスポンスJSON文字列
# 戻り値: 更新されたリクエストJSON文字列
function _provider_process_tool_calls
{
    local request_data="$1"
    local response="$2"
    
    # モデルの応答（function callを含む）をcontentsに追加
    model_parts=$(echo "$response" | jq -c '.candidates[0].content.parts')
    if [ -z "$model_parts" ] || [ "$model_parts" = "null" ]; then
        echo "$response" >&2
        return 1
    fi
    
    updated_request=$(echo "$request_data" | jq --argjson model_parts "$model_parts" \
        '.contents += [{"role": "model", "parts": $model_parts}]')
    
    if [ $? -ne 0 ]; then
        return 1
    fi
    
    # 各function callを処理してfunction responseを収集
    func_responses_file="$AISH_SESSION/func_responses_$$.json"
    echo "[]" > "$func_responses_file"
    
    # function callのリストを一時ファイルに保存
    func_calls_file="$AISH_SESSION/func_calls_$$.json"
    echo "$response" | jq -c '.candidates[0].content.parts[] | select(.functionCall != null) | .functionCall' > "$func_calls_file"
    
    # 各function callを処理
    while IFS= read -r func_call; do
        if [ -z "$func_call" ]; then
            continue
        fi
        func_name=$(echo "$func_call" | jq -r '.name')
        func_args=$(echo "$func_call" | jq -r '.args')
        
        if [ "$func_name" = "execute_shell_command" ]; then
            command=$(echo "$func_args" | jq -r '.command')
            
            # シェルコマンドを実行
            result=$(execute_shell_command "$command")
            
            # function responseを生成
            func_response=$(echo "$result" | jq -c '{functionResponse: {name: "execute_shell_command", response: .}}')
            if [ $? -ne 0 ]; then
                rm -f "$func_responses_file" "$func_calls_file"
                return 1
            fi
            
            # 配列に追加
            echo "$(cat "$func_responses_file")" | jq --argjson func_res "$func_response" '. += [$func_res]' > "${func_responses_file}.new"
            if [ $? -ne 0 ]; then
                rm -f "$func_responses_file" "$func_calls_file"
                return 1
            fi
            mv "${func_responses_file}.new" "$func_responses_file"
        fi
    done < "$func_calls_file"
    
    # すべてのfunction responseをcontentsに追加
    func_responses=$(cat "$func_responses_file")
    final_request=$(echo "$updated_request" | jq --argjson func_responses "$func_responses" \
        '.contents += ($func_responses | map({"role": "function", "parts": [.]}))')
    
    rm -f "$func_responses_file" "$func_calls_file"
    
    if [ $? -ne 0 ]; then
        return 1
    fi
    
    echo "$final_request"
}

# 共通ライブラリを使用してクエリを実行
function query
{
  _llm_driver_query "$@"
}
