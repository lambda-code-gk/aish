#!/usr/bin/env bash

set -eo pipefail

# 対応しているモデルの一覧
SUPPORTED_MODELS=(
#  "gemini-1.5-flash"
#  "gemini-1.5-pro"
#  "gemini-2.0-flash-exp"
#  "gemini-2.0-flash"
#  "gemini-2.5-pro-preview-03-25"
#  "gemini-2.5-flash-preview-04-17"
#  "gemini-2.5-pro-preview-05-06"
#  "gemini-2.5-flash-preview-05-20"
  "gemini-3-flash-preview"
)

MODEL="gemini-3-flash-preview"

LOG="$AISH_SESSION"/log.json

# 共通ライブラリを読み込む
. "$AISH_HOME/lib/agent_approve.sh"
. "$AISH_HOME/lib/tool_execute_shell_command.sh"
. "$AISH_HOME/lib/memory_manager.sh"
. "$AISH_HOME/lib/query_entry.sh"
. "$AISH_HOME/lib/llm_driver.sh"

# Gemini形式のリクエストJSONを生成（通常モード）
function _provider_make_request_payload
{
  query=$1
  system=$2

  echo '{'

  if [ ! -z "$system" ];
  then
    echo '"system_instruction": {"parts": {"text": '$(echo "$system" | json_string)'}},'
  fi


  echo '"contents":['

  while IFS= read -r file; do
    if [[ "$file" =~ "_user.txt" ]]; then
      role="user"
    else
      role="model"
    fi
    echo -n '  {"role": "'$role'", "parts":[{"text": '
    cat "$file" | json_string
    echo '}]},'
  done
  user_input=$(echo -e "----\n# user message:\n$query" | json_string)
  echo '  {"role": "user", "parts":[{"text": '"$user_input"'}]}'
  echo ']'
  echo '}'
}

# Gemini形式のリクエストJSONを生成（エージェントモード）
function _provider_make_request_payload_agent
{
  query=$1
  system=$2

  echo '{'

  if [ ! -z "$system" ];
  then
    echo '"system_instruction": {"parts": {"text": '$(echo "$system" | json_string)'}},'
  fi

  echo '"tools": ['
  echo '  {"functionDeclarations": ['
  echo '    {"name": "execute_shell_command", "description": "Execute a shell command and return the result with exit code, stdout, and stderr", "parameters": {"type": "object", "properties": {"command": {"type": "string", "description": "The shell command to execute"}}, "required": ["command"]}},'
  echo '    {"name": "save_memory", "description": "Save useful information to the memory system. The memory will be stored in the project-specific directory if .aish/memory exists, otherwise in the global directory.", "parameters": {"type": "object", "properties": {"content": {"type": "string", "description": "The content to remember"}, "category": {"type": "string", "description": "Category: code_pattern, error_solution, workflow, best_practice, configuration, etc.", "default": "general"}, "keywords": {"type": "array", "items": {"type": "string"}, "description": "Keywords for searching this memory later"}}, "required": ["content"]}},'
  echo '    {"name": "search_memory", "description": "Search memories related to the query. Searches both project-specific and global memories.", "parameters": {"type": "object", "properties": {"query": {"type": "string", "description": "Search query"}, "category": {"type": "string", "description": "Filter by category (optional)"}, "limit": {"type": "integer", "description": "Maximum number of results", "default": 5}}, "required": ["query"]}}'
  echo '  ]}'
  echo '],'

  echo '"contents":['

  while IFS= read -r file; do
    if [[ "$file" =~ "_user.txt" ]]; then
      role="user"
    elif [[ "$file" =~ "_function.txt" ]]; then
      role="function"
    else
      role="model"
    fi
    
    # function roleの場合は特別な処理
    if [ "$role" = "function" ]; then
      # function response形式で出力
      echo -n '  {"role": "function", "parts":['
      cat "$file"
      echo ']},'
    else
      echo -n '  {"role": "'$role'", "parts":[{"text": '
      cat "$file" | json_string
      echo '}]},'
    fi
  done
  user_input=$(echo -e "----\n# user message:\n$query" | json_string)
  echo '  {"role": "user", "parts":[{"text": '"$user_input"'}]}'
  echo ']'
  echo '}'
}

# プロバイダ固有: Gemini APIへのHTTPリクエスト実行
# 引数: request_file - リクエストJSONファイルのパス
# 戻り値: レスポンスJSON文字列（標準出力）
# 終了コード: curlの終了コード（0=成功、非0=エラー）
function _provider_make_http_request
{
    local request_file="$1"
    curl -s "https://generativelanguage.googleapis.com/v1beta/models/${MODEL}:generateContent?key=${GEMINI_API_KEY}" \
      -H 'Content-Type: application/json' \
      -X POST \
      --data-binary @"$request_file"
}

# プロバイダ固有: レスポンスからテキストを抽出
# 引数: response - レスポンスJSON文字列
# 戻り値: 抽出したテキスト（または "null"）
function _provider_parse_response_text
{
    local response="$1"
    echo "$response" | jq -r '[.candidates[0].content.parts[]? | select(.text != null) | .text] | join("") // empty'
}

# プロバイダ固有: functionCallの有無をチェック
# 引数: response - レスポンスJSON文字列
# 戻り値: "yes" または "no"
function _provider_check_tool_calls
{
    local response="$1"
    echo "$response" | jq -e '.candidates[0].content.parts[] | select(.functionCall != null)' > /dev/null 2>&1 && echo "yes" || echo "no"
}

# プロバイダ固有: functionCallを処理して更新されたリクエストを返す
# 引数: request_data - 現在のリクエストJSON文字列
#      response - レスポンスJSON文字列
# 戻り値: 更新されたリクエストJSON文字列
function _provider_process_tool_calls
{
    local request_data="$1"
    local response="$2"
    
    # モデルの応答（function callを含む）をcontentsに追加
    model_parts=$(echo "$response" | jq -c '.candidates[0].content.parts')
    if [ -z "$model_parts" ] || [ "$model_parts" = "null" ]; then
        echo "$response" >&2
        return 1
    fi
    
    updated_request=$(echo "$request_data" | jq --argjson model_parts "$model_parts" \
        '.contents += [{"role": "model", "parts": $model_parts}]')
    
    if [ $? -ne 0 ]; then
        return 1
    fi
    
    # 各function callを処理してfunction responseを収集
    func_responses_file="$AISH_SESSION/func_responses_$$.json"
    echo "[]" > "$func_responses_file"
    
    # function callのリストを一時ファイルに保存
    func_calls_file="$AISH_SESSION/func_calls_$$.json"
    echo "$response" | jq -c '.candidates[0].content.parts[] | select(.functionCall != null) | .functionCall' > "$func_calls_file"
    
    # 各function callを処理
    while IFS= read -r func_call; do
        if [ -z "$func_call" ]; then
            continue
        fi
        func_name=$(echo "$func_call" | jq -r '.name')
        func_args=$(echo "$func_call" | jq -r '.args')
        
        if [ "$func_name" = "execute_shell_command" ]; then
            command=$(echo "$func_args" | jq -r '.command')
            
            # シェルコマンドを実行
            result=$(execute_shell_command "$command")
            
            # function responseを生成
            func_response=$(echo "$result" | jq -c '{functionResponse: {name: "execute_shell_command", response: .}}')
            if [ $? -ne 0 ]; then
                rm -f "$func_responses_file" "$func_calls_file"
                return 1
            fi
            
            # 配列に追加
            echo "$(cat "$func_responses_file")" | jq --argjson func_res "$func_response" '. += [$func_res]' > "${func_responses_file}.new"
            if [ $? -ne 0 ]; then
                rm -f "$func_responses_file" "$func_calls_file"
                return 1
            fi
            mv "${func_responses_file}.new" "$func_responses_file"
        elif [ "$func_name" = "save_memory" ]; then
            content=$(echo "$func_args" | jq -r '.content')
            category=$(echo "$func_args" | jq -r '.category // "general"')
            keywords=$(echo "$func_args" | jq -r '.keywords // [] | join(",")')
            
            result=$(save_memory "$content" "$category" "$keywords")
            
            func_response=$(echo "$result" | jq -c --arg name "$func_name" '{functionResponse: {name: $name, response: .}}')
            echo "$(cat "$func_responses_file")" | jq --argjson func_res "$func_response" '. += [$func_res]' > "${func_responses_file}.new"
            mv "${func_responses_file}.new" "$func_responses_file"
        elif [ "$func_name" = "search_memory" ]; then
            query_str=$(echo "$func_args" | jq -r '.query')
            category=$(echo "$func_args" | jq -r '.category // ""')
            limit=$(echo "$func_args" | jq -r '.limit // 5')
            
            result=$(search_memory_efficient "$query_str" "$category" "$limit")
            
            func_response=$(echo "$result" | jq -c --arg name "$func_name" '{functionResponse: {name: $name, response: .}}')
            echo "$(cat "$func_responses_file")" | jq --argjson func_res "$func_response" '. += [$func_res]' > "${func_responses_file}.new"
            mv "${func_responses_file}.new" "$func_responses_file"
        fi
    done < "$func_calls_file"
    
    # すべてのfunction responseをcontentsに追加
    func_responses=$(cat "$func_responses_file")
    final_request=$(echo "$updated_request" | jq --argjson func_responses "$func_responses" \
        '.contents += ($func_responses | map({"role": "function", "parts": [.]}))')
    
    rm -f "$func_responses_file" "$func_calls_file"
    
    if [ $? -ne 0 ]; then
        return 1
    fi
    
    echo "$final_request"
}

# プロバイダ固有: APIから利用可能なモデル一覧を取得
# 戻り値: モデル名のリスト（改行区切り）
function _provider_list_available_models
{
    if [ -z "$GEMINI_API_KEY" ]; then
        puts_error "GEMINI_API_KEY is not set"
        return 1
    fi
    
    response=$(curl -s "https://generativelanguage.googleapis.com/v1beta/models?key=${GEMINI_API_KEY}")
    if [ $? -ne 0 ]; then
        puts_error "Failed to fetch models from Gemini API"
        return 1
    fi
    
    # エラーレスポンスのチェック
    if echo "$response" | jq -e '.error' > /dev/null 2>&1; then
        error_msg=$(echo "$response" | jq -r '.error.message // .error')
        puts_error "Gemini API error: $error_msg"
        return 1
    fi
    
    echo "$response" | jq -r '.models[]? | select(.supportedGenerationMethods[]? | contains("generateContent")) | .name' | sed 's|^models/||'
}

# 共通ライブラリを使用してクエリを実行
function query
{
  _llm_driver_query "$@"
}
