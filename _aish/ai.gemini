#!/usr/bin/env bash

set -eo pipefail

# 対応しているモデルの一覧
SUPPORTED_MODELS=(
#  "gemini-1.5-flash"
#  "gemini-1.5-pro"
#  "gemini-2.0-flash-exp"
#  "gemini-2.0-flash"
#  "gemini-2.5-pro-preview-03-25"
#  "gemini-2.5-flash-preview-04-17"
#  "gemini-2.5-pro-preview-05-06"
#  "gemini-2.5-flash-preview-05-20"
  "gemini-3-flash-preview"
)

MODEL="${MODEL:-gemini-3-flash-preview}"
TEMPERATURE="${TEMPERATURE:-0.7}"

LOG="$AISH_SESSION"/log.json

# 共通ライブラリを読み込む
. "$AISH_HOME/lib/agent_approve.sh"
. "$AISH_HOME/lib/tool_helper.sh"
. "$AISH_HOME/lib/tool_execute_shell_command.sh"
. "$AISH_HOME/lib/tool_save_memory.sh"
. "$AISH_HOME/lib/tool_search_memory.sh"
. "$AISH_HOME/lib/memory_manager.sh"
. "$AISH_HOME/lib/query_entry.sh"
. "$AISH_HOME/lib/llm_driver.sh"

# 全てのtoolファイルを読み込む
_load_all_tool_files

# Gemini形式のリクエストJSONを生成（通常モード）
function _provider_make_request_payload
{
  query=$1
  system=$2

  echo '{'

  if [ ! -z "$system" ];
  then
    echo '"system_instruction": {"parts": {"text": '$(echo "$system" | json_string)'}},'
  fi


  echo '"contents":['

  while IFS= read -r file; do
    if [[ "$file" =~ "_user.txt" ]]; then
      role="user"
    else
      role="model"
    fi
    echo -n '  {"role": "'$role'", "parts":[{"text": '
    cat "$file" | json_string
    echo '}]},'
  done
  user_input=$(echo -e "----\n# user message:\n$query" | json_string)
  echo '  {"role": "user", "parts":[{"text": '"$user_input"'}]}'
  echo ']'
  echo '}'
}

# Gemini形式のリクエストJSONを生成（エージェントモード）
function _provider_make_request_payload_agent
{
  query=$1
  system=$2

  echo '{'

  if [ ! -z "$system" ];
  then
    echo '"system_instruction": {"parts": {"text": '$(echo "$system" | json_string)'}},'
  fi

  # 動的にtool定義を読み込む
  local tool_definitions
  tool_definitions=$(_load_all_tool_definitions_gemini)
  
  # tool定義をGemini形式に変換して出力
  echo '"tools": ['
  echo '  {"functionDeclarations": '
  echo "$tool_definitions"
  echo '  }]'
  echo ','

  echo '"contents":['

  while IFS= read -r file; do
    if [[ "$file" =~ "_user.txt" ]]; then
      role="user"
    elif [[ "$file" =~ "_function.txt" ]]; then
      role="function"
    else
      role="model"
    fi
    
    # function roleの場合は特別な処理
    if [ "$role" = "function" ]; then
      # function response形式で出力
      echo -n '  {"role": "function", "parts":['
      cat "$file"
      echo ']},'
    else
      echo -n '  {"role": "'$role'", "parts":[{"text": '
      cat "$file" | json_string
      echo '}]},'
    fi
  done
  user_input=$(echo -e "----\n# user message:\n$query" | json_string)
  echo '  {"role": "user", "parts":[{"text": '"$user_input"'}]}'
  echo ']'
  echo '}'
}

# プロバイダ固有: Gemini APIへのHTTPリクエスト実行
# 引数: request_file - リクエストJSONファイルのパス
# 戻り値: レスポンスJSON文字列（標準出力）
# 終了コード: curlの終了コード（0=成功、非0=エラー）
function _provider_make_http_request
{
    local request_file="$1"
    curl -s "https://generativelanguage.googleapis.com/v1beta/models/${MODEL}:generateContent?key=${GEMINI_API_KEY}" \
      -H 'Content-Type: application/json' \
      -X POST \
      --data-binary @"$request_file"
}

# プロバイダ固有: レスポンスからテキストを抽出
# 引数: response - レスポンスJSON文字列
# 戻り値: 抽出したテキスト（または "null"）
function _provider_parse_response_text
{
    local response="$1"
    echo "$response" | jq -r '[.candidates[0].content.parts[]? | select(.text != null) | .text] | join("") // empty'
}

# プロバイダ固有: functionCallの有無をチェック
# 引数: response - レスポンスJSON文字列
# 戻り値: "yes" または "no"
function _provider_check_tool_calls
{
    local response="$1"
    echo "$response" | jq -e '.candidates[0].content.parts[] | select(.functionCall != null)' > /dev/null 2>&1 && echo "yes" || echo "no"
}

# プロバイダ固有: functionCallを処理して更新されたリクエストを返す
# 引数: request_data - 現在のリクエストJSON文字列
#      response - レスポンスJSON文字列
# 戻り値: 更新されたリクエストJSON文字列
function _provider_process_tool_calls
{
    local request_data="$1"
    local response="$2"
    
    # モデルの応答（function callを含む）をcontentsに追加
    model_parts=$(echo "$response" | jq -c '.candidates[0].content.parts')
    if [ -z "$model_parts" ] || [ "$model_parts" = "null" ]; then
        echo "$response" >&2
        return 1
    fi
    
    updated_request=$(echo "$request_data" | jq --argjson model_parts "$model_parts" \
        '.contents += [{"role": "model", "parts": $model_parts}]')
    
    if [ $? -ne 0 ]; then
        return 1
    fi
    
    # 各function callを処理してfunction responseを収集
    func_responses_file="$AISH_SESSION/func_responses_$$.json"
    echo "[]" > "$func_responses_file"
    
    # function callのリストを一時ファイルに保存
    func_calls_file="$AISH_SESSION/func_calls_$$.json"
    echo "$response" | jq -c '.candidates[0].content.parts[] | select(.functionCall != null) | .functionCall' > "$func_calls_file"
    
    # 各function callを処理
    while IFS= read -r func_call; do
        if [ -z "$func_call" ]; then
            continue
        fi
        func_name=$(echo "$func_call" | jq -r '.name')
        func_args=$(echo "$func_call" | jq -r '.args')
        
        # 動的にtool実行処理を呼び出す（Gemini形式ではtool_call_idは不要なので空文字列を渡す）
        result=$(_execute_tool_call "$func_name" "" "$func_args" "gemini")
        execute_exit_code=$?
        
        if [ $execute_exit_code -ne 0 ] || [ -z "$result" ]; then
            # エラーが発生した場合はエラーメッセージを返す
            if [ -z "$result" ]; then
                result='{"error": "Tool execution failed"}'
            fi
            # Gemini APIは配列を直接受け付けないため、配列の場合はオブジェクトでラップ
            wrapped_result=$(echo "$result" | jq 'if type == "array" then {results: .} else . end')
            func_response=$(echo "$wrapped_result" | jq -c --arg name "$func_name" '{functionResponse: {name: $name, response: .}}')
        else
            # Gemini APIは配列を直接受け付けないため、配列の場合はオブジェクトでラップ
            wrapped_result=$(echo "$result" | jq 'if type == "array" then {results: .} else . end')
            # function responseを生成
            func_response=$(echo "$wrapped_result" | jq -c --arg name "$func_name" '{functionResponse: {name: $name, response: .}}')
        fi
        
        if [ $? -ne 0 ]; then
            rm -f "$func_responses_file" "$func_calls_file"
            return 1
        fi
        
        # 配列に追加
        echo "$(cat "$func_responses_file")" | jq --argjson func_res "$func_response" '. += [$func_res]' > "${func_responses_file}.new"
        if [ $? -ne 0 ]; then
            rm -f "$func_responses_file" "$func_calls_file" "${func_responses_file}.new"
            return 1
        fi
        mv "${func_responses_file}.new" "$func_responses_file"
    done < "$func_calls_file"
    
    # すべてのfunction responseをcontentsに追加
    func_responses=$(cat "$func_responses_file")
    final_request=$(echo "$updated_request" | jq --argjson func_responses "$func_responses" \
        '.contents += ($func_responses | map({"role": "function", "parts": [.]}))')
    
    rm -f "$func_responses_file" "$func_calls_file"
    
    if [ $? -ne 0 ]; then
        return 1
    fi
    
    echo "$final_request"
}

# プロバイダ固有: APIから利用可能なモデル一覧を取得
# 戻り値: モデル名のリスト（改行区切り）
function _provider_list_available_models
{
    if [ -z "$GEMINI_API_KEY" ]; then
        puts_error "GEMINI_API_KEY is not set"
        return 1
    fi
    
    response=$(curl -s "https://generativelanguage.googleapis.com/v1beta/models?key=${GEMINI_API_KEY}")
    if [ $? -ne 0 ]; then
        puts_error "Failed to fetch models from Gemini API"
        return 1
    fi
    
    # エラーレスポンスのチェック
    if echo "$response" | jq -e '.error' > /dev/null 2>&1; then
        error_msg=$(echo "$response" | jq -r '.error.message // .error')
        puts_error "Gemini API error: $error_msg"
        return 1
    fi
    
    echo "$response" | jq -r '.models[]? | select(.supportedGenerationMethods[]? | contains("generateContent")) | .name' | sed 's|^models/||'
}

# 共通ライブラリを使用してクエリを実行
function query
{
  _llm_driver_query "$@"
}
