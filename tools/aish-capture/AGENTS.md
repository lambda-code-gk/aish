# aish-capture - AI開発エージェント向け知識ベース

このドキュメントは、`aish-capture`サブプロジェクトにおけるAI開発エージェントが参照すべき約束事、実行方法、実装方針を記録しています。

## プロジェクト概要

- **名前**: `aish-capture`
- **目的**: `script`コマンドの代替となる軽量なPTYキャプチャツール（Rust実装）
- **ディレクトリ**: `tools/aish-capture/`

## 環境設定

### 開発環境・前提条件

* Rust

### ビルド方法

```bash
cd tools/aish-capture
cargo build --release
```

ビルド成果物は `tools/aish-capture/target/release/aish-capture` に生成されます。

## テスト実行方法

### 基本的なテスト実行

```bash
cd tools/aish-capture
./test.sh
```

### PTYが必要なテストの実行

`aish-capture`はPTY（疑似ターミナル）を使用するため、対話的なターミナルが必要です。
非対話的な環境（CI環境など）で実行する場合は、`script`コマンドを使用してPTYをシミュレートします：

```bash
cd tools/aish-capture
script -c './test.sh' -q /dev/null
```

この方法により、すべてのテスト（PTY依存のテストを含む）を実行できます。

### テストの詳細

- テストスクリプト: `tools/aish-capture/test.sh`
- テストドキュメント: `tools/aish-capture/README_TEST.md`
- テスト用ディレクトリ: 実行時に自動生成される一時ディレクトリ（終了時に自動削除）

## 実装方針と約束事

### 依存関係の最小化

**重要な原則**: `aish-capture`は依存を最小化することが要件です。

- 原則として`libc`のみを使用
- `clap`、`serde`、`base64`などのcrateは使用しない
- base64エンコードは最小実装を同梱（`tools/aish-capture/src/util/base64.rs`）
- OS依存箇所は`src/platform/`に分離

### JSONL出力フォーマット

#### エンコード方針（2025年1月1日改訂、2025年1月3日更新）

`stdin`/`stdout`イベントの`data`フィールドは、以下の方針でエンコードされます：

1. **JSON-safeなテキストの場合**:
   - `enc`フィールドを**省略**（オプショナル）
   - `data`フィールドに直接テキストを保存
   - JSON-safeとは、UTF-8として有効で、`\n`、`\r`、`\t`以外の制御文字を含まないこと

2. **ANSIエスケープシーケンスを含む場合**（2025年1月3日追加）:
   - `enc`フィールドを**省略**（オプショナル）
   - `data`フィールドにJSONエスケープ文字列（`\u001b`など）として保存
   - ANSIエスケープシーケンス（CSI、OSC、その他のエスケープシーケンス）は検出され、JSON-safeとして扱われる
   - base64エンコードされず、可読性が向上し、`aish-script`でのパターンマッチングが容易になる

3. **本当のバイナリデータや制御文字を含む場合**:
   - `enc: "b64"`フィールドを追加
   - `data`フィールドにbase64エンコードされた文字列を保存
   - UTF-8として無効なデータのみが該当

#### バッファリング方針（2025年1月1日追加）

UTF-8でエンコードできるテキストデータについては、入力・出力共に改行までを1行にまとめます：

1. **UTF-8テキストの場合**:
   - `TextBuffer`構造体で改行文字（`\n`または`\r\n`）が来るまでバッファリング
   - 改行が来たら、それまでのデータを1つのイベントとして書き出す
   - 複数の行が含まれる場合は、各行が独立したイベントになる

2. **バイナリデータの場合**:
   - バッファリングせず、即座に書き出す
   - base64エンコードして`enc: "b64"`フィールド付きで保存

#### 実装詳細

- 判定関数: `check_json_safe_text()` (`src/logfmt.rs`)
  - ANSIエスケープシーケンス検出関数: `contains_ansi_escape_sequences()` (`src/logfmt.rs`)
    - CSIシーケンス（`\x1B[...]`）、OSCシーケンス（`\x1B]...\x07`）、その他のエスケープシーケンスを検出
  - ANSIエスケープシーケンスを含むデータはJSON-safeとして扱う
- バッファリング: `TextBuffer`構造体 (`src/logfmt.rs`)
  - `append()`: データを追加し、改行が揃った行を返す
  - `flush()`: EOF時に残っているデータを書き出す
- テキストデータの場合、可読性とファイルサイズの削減がメリット
- ANSIエスケープシーケンスはJSONエスケープ文字列として記録（base64エンコード不要）
- 本当のバイナリデータ（UTF-8として無効なデータ）のみbase64エンコード

#### 例

**テキスト出力の場合**:
```json
{"v":1,"t_ms":...,"type":"stdout","n":13,"data":"hello world\r\n"}
```

**ANSIエスケープシーケンスを含む場合**（2025年1月3日更新）:
```json
{"v":1,"t_ms":...,"type":"stdout","n":14,"data":"\u001b[31mRED\u001b[0m\n"}
```

**本当のバイナリデータを含む場合**:
```json
{"v":1,"t_ms":...,"type":"stdout","enc":"b64","n":3,"data":"//79"}
```

### コード構造

```
tools/aish-capture/
├── src/
│   ├── main.rs          # メインエントリーポイント、設定と実行ループ
│   ├── logfmt.rs        # JSONL形式でのログ出力
│   │                    # - write_stdin, write_stdout等
│   │                    # - TextBuffer構造体（テキストバッファリング）
│   ├── platform/        # OS依存コード
│   │   ├── mod.rs
│   │   └── unix.rs      # Unix系OS（Linux/macOS）の実装
│   └── util/
│       ├── mod.rs
│       └── base64.rs    # RFC4648 base64エンコード（最小実装）
├── test.sh              # 自動テストスクリプト
└── Cargo.toml           # Rustプロジェクト設定
```

## 開発時の注意事項

### テストの修正

テストを修正する場合、以下の点に注意：

- `enc`フィールドはオプショナルになったため、テストで必須チェックを削除
- `data`フィールドの存在確認は継続
- テキスト出力、ANSIエスケープシーケンス、バイナリ出力の全てのケースを考慮
- 「含まないことを確認」するテストには`assert_jsonl_not_contains`関数を使用（`! assert_jsonl_contains`は使用しない）

### コード品質

- `unsafe`ブロックは必要最小限に
- エラーハンドリングは適切に行う
- 終了コードは仕様に従う（64: 引数不正、74: I/Oエラー、70: fork/pty失敗、1: その他）

### パフォーマンス

- base64エンコードは必要な場合のみ実行（テキストデータの場合はスキップ）
- UTF-8検証は一度だけ実行（`check_json_safe_text`で判定と変換を同時に行う）
- テキストデータは改行までバッファリングすることで、1行ごとにイベント化し可読性を向上

### バッファリング動作

- stdin/stdout用にそれぞれ`TextBuffer`インスタンスを保持
- UTF-8テキストの場合、改行文字が来るまでデータをバッファに蓄積
- 改行が来たら、バッファの内容を1つのイベントとして書き出す
- EOF時には`flush()`で残っているデータを書き出す
- バイナリデータの場合はバッファリングせず、即座に書き出す

## トラブルシューティング

### cargoが見つからない場合

```bash
export PATH="$HOME/.cargo/bin:$PATH"
```

この設定を追加してください。

### PTYテストが失敗する場合

非対話的な環境では、`script`コマンドを使用：

```bash
script -c './test.sh' -q /dev/null
```

### ビルドエラー

依存関係の問題がある場合、`Cargo.toml`を確認してください。最小依存の方針に従っているか確認します。

## 関連ドキュメント

- **設計ドキュメント**: `plan/01_improve_terminal_capture.md`（プロジェクトルート）
- **テストドキュメント**: `tools/aish-capture/README_TEST.md`
- **プロジェクトREADME**: `README.md`（プロジェクトルート）

## 自律稼働・実装上の重要な知見

### FIFO (Named Pipe) の取り扱い

- **ノンブロッキングオープンとデッドロック**:
  - `O_RDONLY | O_NONBLOCK` で FIFO を開くと、書き込み側がいない場合に即座に EOF (read 0) が返る。これを検知して監視を止めると、後から来た書き込みを無視してデッドロックの原因になる。
  - 解決策として `O_RDWR | O_NONBLOCK` を使用する。これにより、自分自身が書き込み側としてもカウントされ、外部の書き込み側がいなくても EOF が返らなくなる。
- **書き込み側のブロッキング**:
  - テストスクリプト等で FIFO に書き込む際、読み手（aish-capture）が終了していると `open` や `write` が永久にブロックすることがある。
  - テストコードでは `timeout` コマンドを使用して、デッドロックを回避すること。

### PTY (疑似端末) と EOF 処理

- **PTY の EOF 検知**:
  - 子プロセスが終了したり PTY がクローズされた際、`read` は `0` または `EIO` (Linux の場合) を返す。
  - `poll` ループでは `POLLIN` だけでなく `POLLHUP` や `POLLERR` も監視し、これらがセットされた場合は `read` を試みた上で、適切にループを抜ける必要がある。そうしないとビジーウェイト（CPU 100%）に陥る。
- **マスター FD の非ブロッキング化**:
  - `poll` と `read` の間でのブロックを避けるため、PTY マスター FD も `O_NONBLOCK` に設定することが望ましい。

### 非 TTY 環境（CI、パイプ等）への対応

- **ioctl の失敗**:
  - `ioctl(TIOCGWINSZ)` や `tcgetattr` は、標準入力がターミナルでない場合に `Inappropriate ioctl for device` (errno 25) で失敗する。
  - `isatty(stdin_fd)` で事前にチェックし、非 TTY の場合はターミナル設定の変更をスキップし、デフォルトのウィンドウサイズ（例: 80x24）を使用すること。

## 更新履歴

- **2025年1月3日**: ログフォーマット改善（Phase 1.5）
  - ANSIエスケープシーケンスをJSONエスケープ文字列として記録する機能を実装
  - `contains_ansi_escape_sequences()`関数を追加（CSI、OSC、その他のエスケープシーケンスを検出）
  - ANSIエスケープシーケンスを含むデータはbase64エンコードせず、JSONエスケープ文字列（`\u001b`など）として記録
  - 本当のバイナリデータ（UTF-8として無効なデータ）のみbase64エンコード
  - テスト 10.5 (ANSIエスケープシーケンス) と 10.6 (バイナリデータ) を追加
  - テストフレームワークに`assert_jsonl_not_contains`関数を追加

- **2026年1月3日**: FIFO入力機能の追加と堅牢化
  - `--input-fifo` オプションの実装
  - FIFO を `O_RDWR | O_NONBLOCK` で開くことでデッドロックを回避
  - PTY マスター FD の非ブロッキング化と EOF 処理の改善
  - 非 TTY 環境（パイプ入力等）での `ioctl` エラーを回避する修正
  - テスト 11-13 (FIFO関連) を追加
